# Анимации: React Transition Group, Motion

__`React-transition-group`__ - легковесная библиотека для обработки изменений состояний компонента, помогает удобно реагировать на переходы в React-приложениях. Позволяет декларативно описать переход от одного состояния компонента к другому с течением времени.

__`Под переходом`__ подразумевается простое изменение значения состояния `state`, а мы уже можем подвязать под этой свой смысл. То есть переходом может быть что угодно, и не обязательно "появление" (монтирование) и "исчезновение" (размонтироваание) элемента, а может перемещение элемента из одной области в другую, и так далее... Все это мы уже сами опеределяем в стилях под каждое состояние, а библиотека лишь дает нам такую возможность.

__Билиотека__:  
* __Позволяет__ описать стили для того или иного этапа жизни компонента (`state`);
* __Предоставляет__ возможность обработки событий в процессе переходов: "что нужно сделать в таких-то этапах жизни компонента";
* __Не дает__ интрументария для действий над компонентами: монтирование, размонтирование итд;
* __Не содержит__ сами CSS-анимации, классы и прочее;

То есть действия с компонентами мы реализуем сами, а библиотека лишь позволяет описать как стиль компонентов должен реагировать на эти события.
Чаще всего библиотека используется для анимации монтажа и демонтажа компонента, но также может использоваться для описания переходных состояний.

<br>

## Установка в проект:
Добавляем прод-зависимость
```
npm i react-transition-group
```
Импортируем в модуль компонента
```javascript
import { Transition, CSSTransition, SwitchTransition, TransitionGroup } from 'react-transition-group'
```

<br>

## Существует 4 основных состояния `state`:

<img title="Изменение in и состояния" alt="Изменение in и состояния" width="650" src="https://github.com/BR-NZ/synopsis/assets/24506129/11c5e825-10f7-45b0-b871-4015145c4b47">

* `entering` – процесс "вхождения", длиной `timeout` секунд;
* `entered` – компонент уже "вошел";
* `exiting` – процесс "выхождения", длиной `timeout` секунд;
* `exited` – компонент уже "вышел";

<br>

## Они вызывают 6 событий:
<img title="Вхождение: изменение in и события" alt="Вхождение: изменение in и события" width="650" src="https://github.com/BR-NZ/synopsis/assets/24506129/1281c200-5475-4bfc-a712-03bd824caed6">

* `onEnter` – вызывается перед применением статуса `entering`: 
```
onEnter={(node, isAppearing) => {}}

// получает параметр `isAppearing` как индикатор вхождения первоначальнго монтирования
// при наличии пропса nodeRef у компонента - node не передается
``` 
* `onEntering` – вызывается после применения статуса `entering`: 
```
onEntering={(node, isAppearing) => {}}
```
* `onEntered` – вызывается после применения статуса `entered`: 
```
onEntered={(node, isAppearing) => {}}
```

<img title="Выхождение: изменение in и события" alt="Выхождение: изменение in и события" width="650" src="https://github.com/BR-NZ/synopsis/assets/24506129/caa3af32-5ace-4f95-b42a-2e6549b057e5">

* `onExit` – вызывается перед применением статуса `exiting`: 
```
onExit={(node) => {}}
```
* `onExiting` – вызывается после применения статуса `exiting`: 
```
onExiting={(node) => {}}
```
* `onExited` – вызывается после применения статуса `exited`: 
```
onExited={(node) => {}}
```

К примеру, в этих коллбеках (обработчиках событий) можно выполнять какие-то своевременные действия: скрыть кнопку активации, изменять ее положение и пр.

<br>

## Пропс `in` – управляет переходами
__`props-in`__ – ключевой пропс компонентов `<Transition>` и `<CSSTransition>` библиотеки, принимает только `bool`-значения, которыми переключает состояния компонента.

Когда пропс-`in` переходит:  
1.  __Из `true` в `false`__
* Состояние `state` компонента меняет значение: `exiting` на `exited`
* На компоненте происходят по порядку 3 события: `onEnter`  → `onEntering` → `onEntered`
2.  __Из `false` в `true`__
* Состояние `state` компонента меняет значение: `entering` на `entered`
* На компоненте происходят по порядку 3 события: `onExit` → `onExiting` → `onExited`

Обычно, в проп `in={...someState}` передают один из `state` компонента или пропс, полученный из внешнего компонента.

<br>

## Пропс `timeout` - время перехода
__`timeout`__ –  - продолжительность перехода в мс, можно определять одним значением для всех переходов или для каждого перехода в отдельности. Стоит заметить что этот пропс просто влияет на скорость изменения значения `state`, а не на скорость воспроизведения анимации, для этого его значения нужно встроить в `css-свойство`.

```javascript
timeout={ 500 }

timeout={{
  appear: 500,
  enter: 300,
  exit: 500
}}
```

* `appear` – время для первого появления элемента (по умолчанию = `enter`);
* `enter` – вермя для следующих вхождений (по умолчанию = 0);
* `exit` – время выхода (по умолчанию = 0);

## Пропс `appear` - время перехода
По умолчанию, первое вхождение элемента при загрузке компонента и при первом монтировании не анимируется, независимо от значения `in`. 

Для изменения этого поведения, следует установить `appear={true}` и `in={true}`. А для `<SSTransition>` следует также создать css-классы вида: `*-appear`, `*-appear-active`, `*-appear-done`.

<br>

## Главные компоненты `<Transition>` и `<CSSTransition>`
Они выполняют основные функции библиотеки: 
1. Получают от нас стили для разных состояний компонента;
2. Воспроизводят переданные им стили в разных состояниях компонента;
3. Предоставляют свои события этого процесса и дают возможность на них реагировать в колбек-функциях;

#### В чем разница:
* <Transition> будет задавать компоненту разные `inline-стили` под каждое состояние;
* <CSSTransition> будет просто брать заготовленные `css-классы` и задавать компоненту под каждое состояние свой;

<br>

### `<Transition>` (инлайн-стили перехода)
Это базовый компонент, который не использует никаких CSS-классов проекта, вместо этого он задает inline-стили прямо в коде компонента.

Внутри себя содержит `рендер-функцию`, которая получает текущий `state` и на основе него должна __конфигурировать отображаемый компонен особым образом__, а после вернуть его.  

#### Наглядный пример применения:  
```javascript
const duration = 300;

// объект-стилей базовых (не привязанных к состоянию)
const defaultStyle = {
  transition: `opacity ${duration}ms ease-in-out`,
  opacity: 0,
}

// объект-стилей под промежуточные состояния (state)
const transitionStyles = {
  entering: { opacity: 1 },
  entered: { opacity: 1 },
  exiting: { opacity: 0 },
  exited: { opacity: 0 },
};
  
const someComp = () => {
  const [show, setShow] = useState(true);
  const nodeRef = useRef(null);
  
  return (
    <Transition in={show} timeout={duration} nodeRef={nodeRef}>
      {
      state => (
        <div ref={nodeRef} style={{
          ...defaultStyle, // базовые стили будут всегда (на любом state)
          ...transitionStyles[state] // под каждый state добавятся свои стили
        }}>
          Я буду исчезать !!!
          <Button onClick={() => setShow(false)}>Закрыть</Button>
        </div>
      )
      }
    </Transition>
  )
}
```

#### Пропсы дополнительные:
* __`nodeRef`__ – ссылка на DOM-элемент, который "нуждается" в переходе;
* __`mountOnEnter`__ – по умолчанию отображаемый компонент монтируется в DOM вместе с родительским `<Transition>`. Для того, чтобы монтировать компонент как-бы `"лениво"` при первом `in={true}`, следует установить `mountOnEnter`. После первого вхождения `in={true}`, компонент так и останется в DOM, если не передать пропс `unmountOnExit`;
* __`unmountOnExit`__ – по умолчанию дочерний компонент остается смонтированным в DOM при достижении состояния `exited`. Установка пропса `unmountOnExit` означает, что компонент будет размонтирован, то есть удален из DOM после выхода;

<br>

### `<CSSTransition>` (класс перехода)
Этот компонент основан на `<Transition>` и имеет те же пропсы, работает по тому же принципу, но задает стили в виде `css-классов`. 

Чтобы классы корректно применялись в зависимости от состояния компонента, они должны именоваться в определенном стиле. То есть, ему в пропсе `classNames` задается префикс всех будущих классов. 

#### Образец создания классов:  
```css
// уже вошел
.message-enter {
  opacity: 0;
  transform: scale(0.9);
}
// начался процесс вхождения
// (этот класс + предыдущий будет применяться duration's)
.message-enter-active {
  opacity: 1;
  transform: translateX(0);
  transition: opacity 300ms, transform 300ms;
}
// переход закончился 
.message-enter-done {
  opacity: 0;
  transform: scale(0.9);
}
// уже вышел
.message-exit {
  opacity: 1;
}
// начался процесс выхождения
// (этот класс + предыдущий будет применяться duration's)
.message-exit-active {
  opacity: 0;
  transform: scale(0.9);
  transition: opacity 300ms, transform 300ms;
}
```

#### Как применяются эти классы
В зависимости от типа перехода, значения `state` происходит изменения в классах у отображаемого компонента.  

При вхождении:  
<img title="Изменение state и классов" alt="Изменение state и классов" width="650" src="https://github.com/BR-NZ/synopsis/assets/24506129/dae08159-0998-4531-8519-e310181eccab">

При выхождении:  
<img title="Изменение state и классов" alt="Изменение state и классов" width="650" src="https://github.com/BR-NZ/synopsis/assets/24506129/a3087e94-f052-48f4-a544-e53334103826">

#### Как применяются эти классы:
* Они объединяются с существующими классами компонента, так что если вы хотите определить некоторые базовые стили, то можете использовать `className`, не опасаясь, что базовые стили будут перезаписаны;
* Если компонент монтируется с `in={false}`, никакие классы к нему не применяются (включая `*-exit-done`);
* `fade-appear-done` и `fade-enter-done` применяются одновременно. Это позволяет определять различное поведение при завершении появления и обычного вхождения с помощью таких селекторов, как `.fade-enter-done:not(.fade-appear-done)`. В противном случае, вы можете использовать `fade-enter-done` для обработки обоих случаев.
* Если хотим иметь анимацию первоначального появления компонента при загрузке - передаем пропс `appear={true}`, а также создаем классы вида `*-appear-active/done`

#### Наглядный пример применения:  
```javascript
const Example = () => {
  const [showButton, setShowButton] = useState(true)
  const [showMessage, setShowMessage] = useState(false)
  const ref = useRef()

  return (
    <Container className='pt-4'>
      { showButton ? <Button onClick={() => setShowMessage(true)}>Показать сообщение</Button> ? null }

      <CSSTransition
        in={ showMessage }
        timeout={ 300 }
        classNames='message'
        onEnter={() => setShowButton(false)} // функции-обработчики
        onExited={() => setShowButton(true)} // на разные события
        nodeRef={ref}
        unmountOnExit // удалить из DOM при завершении перехода
      >
        <SomeMessageComponent ref={ref}>
          <p>Данное сообщение анимируется с помощью переходов</p>
          <Button onClick={() => setShowMessage(false)}>Закрыть</Button>
        </SomeMessageComponent>
      </CSSTransition>
    </Container>
  )
}
```

### `<SwitchTransition>` (вариант перехода)


### `<TransitionGroup>` (обертка)
  

<br>

