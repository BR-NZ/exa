# Анимации: React Transition Group, Motion

__`React-transition-group`__ - легковесная библиотека для обработки изменений состояний компонента, помогает удобно реагировать на переходы в React-приложениях. Позволяет декларативно описать переход от одного состояния компонента к другому с течением времени.

__`Под переходом`__ подразумевается простое изменение значения состояния `state`, а мы уже можем подвязать под этой свой смысл. То есть переходом может быть что угодно, и не обязательно "появление" (монтирование) и "исчезновение" (размонтироваание) элемента, а может перемещение элемента из одной области в другую, и так далее... Все это мы уже сами опеределяем в стилях под каждое состояние, а библиотека лишь дает нам такую возможность.

__Билиотека__:  
* __Позволяет__ описать стили для того или иного этапа жизни компонента (`state`);
* __Предоставляет__ возможность обработки событий в процессе переходов: "что нужно сделать в таких-то этапах жизни компонента";
* __Не дает__ интрументария для действий над компонентами: монтирование, размонтирование итд;
* __Не содержит__ сами CSS-анимации, классы и прочее;

То есть действия с компонентами мы реализуем сами, а библиотека лишь позволяет описать как стиль компонентов должен реагировать на эти события.
Чаще всего библиотека используется для анимации монтажа и демонтажа компонента, но также может использоваться для описания переходных состояний.

<br>

## Установка в проект:
Добавляем прод-зависимость
```
npm i react-transition-group
```
Импортируем в модуль компонента
```javascript
import { Transition, CSSTransition, SwitchTransition, TransitionGroup } from 'react-transition-group'
```

<br>

## Существует 4 основных состояния `state`:

<img title="Изменение in и состояния" alt="Изменение in и состояния" width="650" src="https://github.com/BR-NZ/synopsis/assets/24506129/11c5e825-10f7-45b0-b871-4015145c4b47">

* `entering` – процесс "вхождения", длиной `timeout` секунд;
* `entered` – компонент уже "вошел";
* `exiting` – процесс "выхождения", длиной `timeout` секунд;
* `exited` – компонент уже "вышел";

<br>

## Они вызывают 6 событий:
<img title="Вхождение: изменение in и события" alt="Вхождение: изменение in и события" width="650" src="https://github.com/BR-NZ/synopsis/assets/24506129/1281c200-5475-4bfc-a712-03bd824caed6">

* `onEnter` – вызывается перед применением статуса `entering`: 
```
onEnter={(node, isAppearing) => {}}

// получает параметр `isAppearing` как индикатор вхождения первоначальнго монтирования
// при наличии пропса nodeRef у компонента - node не передается
``` 
* `onEntering` – вызывается после применения статуса `entering`: 
```
onEntering={(node, isAppearing) => {}}
```
* `onEntered` – вызывается после применения статуса `entered`: 
```
onEntered={(node, isAppearing) => {}}
```

<img title="Выхождение: изменение in и события" alt="Выхождение: изменение in и события" width="650" src="https://github.com/BR-NZ/synopsis/assets/24506129/caa3af32-5ace-4f95-b42a-2e6549b057e5">

* `onExit` – вызывается перед применением статуса `exiting`: 
```
onExit={(node) => {}}
```
* `onExiting` – вызывается после применения статуса `exiting`: 
```
onExiting={(node) => {}}
```
* `onExited` – вызывается после применения статуса `exited`: 
```
onExited={(node) => {}}
```

К примеру, в этих коллбеках (обработчиках событий) можно выполнять какие-то своевременные действия: скрыть кнопку активации, изменять ее положение и пр.

<br>

## Пропс `in` – управляет переходами
__`props-in`__ – ключевой пропс компонентов `<Transition>` и `<CSSTransition>` библиотеки, принимает только `bool`-значения, которыми переключает состояния компонента.

Когда пропс-`in` переходит:  
1.  __Из `true` в `false`__
* Состояние `state` компонента меняет значение: `exiting` на `exited`
* На компоненте происходят по порядку 3 события: `onEnter`  → `onEntering` → `onEntered`
2.  __Из `false` в `true`__
* Состояние `state` компонента меняет значение: `entering` на `entered`
* На компоненте происходят по порядку 3 события: `onExit` → `onExiting` → `onExited`

Обычно, в проп `in={...someState}` передают один из `state` компонента или пропс, полученный из внешнего компонента.

<br>

## Пропс `timeout` - время перехода
__`timeout`__ –  - продолжительность перехода в мс, можно определять одним значением для всех переходов или для каждого перехода в отдельности. Стоит заметить что этот пропс просто влияет на скорость изменения значения `state`, а не на скорость воспроизведения анимации, для этого его значения нужно встроить в `css-свойство`.

```javascript
timeout={ 500 }

timeout={{
  appear: 500,
  enter: 300,
  exit: 500
}}
```

* `appear` – время для первого появления элемента (по умолчанию = `enter`);
* `enter` – вермя для следующих вхождений (по умолчанию = 0);
* `exit` – время выхода (по умолчанию = 0);

<br>

## Пропс `appear` - первое вхождение
С помощью него можно анимировать первое вхождение комопнента особым образом, отличным от обычного вхождения. По умолчанию, первое вхождение элемента при загрузке компонента не анимируется. 

Для изменения этого поведения, следует установить `appear={true}` и `in={true}`. А для `<SSTransition>` следует также создать css-классы вида: `*-appear`, `*-appear-active`, `*-appear-done`.

<br>

## Другие пропсы (для `<Transition>` и `<CSSTransition>`):
* __`nodeRef`__ – ссылка на DOM-элемент, который "нуждается" в переходе;
* __`mountOnEnter`__ – по умолчанию отображаемый компонент монтируется в DOM вместе с родительским `<Transition>`. Для того, чтобы монтировать компонент как-бы `"лениво"` при первом `in={true}`, следует установить `mountOnEnter`. После первого вхождения `in={true}`, компонент так и останется в DOM, если не передать пропс `unmountOnExit`;
* __`unmountOnExit`__ – по умолчанию дочерний компонент остается смонтированным в DOM при достижении состояния `exited`. Установка пропса `unmountOnExit` означает, что компонент будет размонтирован, то есть удален из DOM после выхода;

<br>

## Свойство `display` не анимируется
Если хотим анимацию появления компонента, например, модального окна – используем пару `opacity` и `visibility`.

* Одно `opacity`, без `visibility` скроет комопнент, но оставит возможность его фокуса и может перегораживать собой другой интерфейс;
* А изменение `display` вообще нельзя анимировать, компонент будет просто резко появляться или исчезать;

<br>

## Составляющие библиотеки 
### Базовый компоненты `<Transition>` и `<CSSTransition>`
Они выполняют основные функции библиотеки: 
1. Получают от нас стили для разных состояний компонента;
2. Воспроизводят переданные им стили в разных состояниях компонента;
3. Предоставляют свои события этого процесса и дают возможность на них реагировать в колбек-функциях;
4. Имеют одинаковый набор `props`;

__В чем разница:__  
* `<Transition>` будет задавать компоненту разные `inline-стили` под каждое состояние;
* `<CSSTransition>` будет просто брать заготовленные `css-классы` и задавать компоненту под каждое состояние свой;

### Компоненты-обертки `<SwitchTransition>` и `<TransitionGroup>`
Они оборачивают базовые компоненты переходов и отслеживают их состояние:  
* `<SwitchTransition>` будет модифицировать рендеринг монтирования или размонтирования одного дочернего компонента;
* `<TransitionGroup>` реагировать на монтирование или размонтирование множества дочерних компонентов и запускать их внутреннюю логику;

<br>

## `<Transition>` (переход в инлайн-стилях)
Это базовый компонент, который не использует никаких CSS-классов проекта, вместо этого он задает inline-стили прямо в коде компонента.

Внутри себя содержит `рендер-функцию`, которая получает текущий `state` и на основе него должна __конфигурировать отображаемый компонен особым образом__, а после вернуть его.  

### Наглядный пример применения:  
```javascript
const duration = 300;

// объект-стилей базовых (не привязанных к состоянию)
const defaultStyle = {
  transition: `opacity ${duration}ms ease-in-out`,
  opacity: 0,
}

// объект-стилей под промежуточные состояния (state)
const transitionStyles = {
  entering: { opacity: 1 },
  entered: { opacity: 1 },
  exiting: { opacity: 0 },
  exited: { opacity: 0 },
};
  
const someComp = () => {
  const [show, setShow] = useState(true);
  const nodeRef = useRef(null);
  
  return (
    <Transition in={show} timeout={duration} nodeRef={nodeRef}>
      {
      state => (
        <div ref={nodeRef} style={{
          ...defaultStyle, // базовые стили будут всегда (на любом state)
          ...transitionStyles[state] // под каждый state добавятся свои стили
        }}>
          Я буду исчезать !!!
          <Button onClick={() => setShow(false)}>Закрыть</Button>
        </div>
      )
      }
    </Transition>
  )
}
```

<br>

## `<CSSTransition>` (переход в классах)
Этот компонент основан на `<Transition>` и имеет те же пропсы, работает по тому же принципу, но задает стили в виде `css-классов`. 

Чтобы компонент `<CSSTransition>` понимал какой класс стоит применить в зависимости от состояния компонента, они должны именоваться в определенном стиле.

`classNames` – специальный пропс, который получает префикс для имени классов, таким образом из всех классов в файле стилей будут выбраны именно совпадающие по префиксу для различных состояний. 

### Образец создания классов:  
```css
// инициировано вхождение
.message-enter {
  opacity: 0;
}
// начался процесс вхождения
// (этот класс + предыдущий будет применяться duration's)
.message-enter-active {
  opacity: 1;
  transition: opacity 300ms;
}
// переход закончился 
.message-enter-done {
  opacity: 1;
}
// инициировано выхождение
.message-exit {
  opacity: 1;
}
// начался процесс выхождения
// (этот класс + предыдущий будет применяться duration's)
.message-exit-active {
  opacity: 0;
  transition: opacity 300ms;
}
// переход закончился 
.message-exit-done {
  opacity: 0;
}
```

### Как применяются эти классы
В зависимости от типа перехода, значения `state` происходит изменения в классах у отображаемого компонента:  

1. Сначала применяется первый класс, например, `*-enter`;
2. Затем почти сразу к нему добавляется класс `*-enter-active`, свидетельствующий о начале перехода; 
3. После завершения перехода для фиксации состояния применяется класс `*-enter-done`;

При вхождении:  
<img title="Изменение state и классов" alt="Изменение state и классов" width="650" src="https://github.com/BR-NZ/synopsis/assets/24506129/dae08159-0998-4531-8519-e310181eccab">

При выхождении:  
<img title="Изменение state и классов" alt="Изменение state и классов" width="650" src="https://github.com/BR-NZ/synopsis/assets/24506129/a3087e94-f052-48f4-a544-e53334103826">

### Особенности применения классов:
* Спец-классы добавляются к обычным классам компонента, так что можно использовать обычный `className`, не опасаясь, что базовые стили будут перезаписаны;
* Если компонент монтируется с `in={false}`, никакие классы к нему не применяются (включая `*-exit-done`);
* `*-appear-done` и `*-enter-done` применяются одновременно. Это позволяет определять различное поведение при завершении появления и обычного вхождения с помощью таких селекторов, как `.*-enter-done:not(.*-appear-done)`. Иначе можно использовать `*-enter-done` для обработки обоих случаев.

### Наглядный пример применения:  
```javascript
const Example = () => {
  const [showButton, setShowButton] = useState(true)
  const [showMessage, setShowMessage] = useState(false)
  const ref = useRef()

  return (
    <Container className='pt-4'>
      { showButton ? <Button onClick={() => setShowMessage(true)}>Показать сообщение</Button> ? null }

      <CSSTransition
        in={ showMessage }
        timeout={ 300 }
        classNames='message'
        onEnter={() => setShowButton(false)} // функции-обработчики
        onExited={() => setShowButton(true)} // на разные события
        nodeRef={ref}
        unmountOnExit // удалить из DOM при завершении перехода
      >
        <SomeMessageComponent ref={ref}>
          <p>Данное сообщение анимируется с помощью переходов</p>
          <Button onClick={() => setShowMessage(false)}>Закрыть</Button>
        </SomeMessageComponent>
      </CSSTransition>
    </Container>
  )
}
```

<br>

## `<SwitchTransition>` – устанавливает режим рендеринга
__`<SwitchTransition>`__ – оборачивает один из базовых компонентов `<Transition>` или `<CSSTransition>` и через пропс `mode` устанавливает ему режим `рендеринга`, на случай замены одного компонента другим.
Как это можно провернуть? Меняя каким-либо образом дочернему компоненту `<Transition>` или `<CSSTransition>` пропс `key`, мы заставляем `React` думать что это уже другой (новый) компонент.
И именно `<SwitchTransition>` в этом случае делает работу по красивой замене компонента "старого" на "новый" заданным в `mode` образом.

### Пропс `mode`– режим перехода
* `out-in` – ждет удаления старого потомка перед добавлением нового;
* `in-out` – добавляет нового потомка, ждет его вхождения и только после этого удаляет старого потомка;
* Значение по умолчанию: `out-in`;

Чтобы удаление старого потомка и добавление нового происходило одновременно – нужен компонент `<TransitionGroup>`;

__[Пример работы](https://reactcommunity.org/react-transition-group/switch-transition)__

<br>

## `<TransitionGroup>` – отслеживание списка компонентов
__`<TransitionGroup>`__ – создан для удобного отслеживания нескольких базовых компонентов `<Transition>` или `<CSSTransition>` внутри себя. За счет внутреннего механизма отслеживания обернутых компонентов позволяет исключить у них применение `пропса-in`, то есть внутренние компоненты больше не нуждаются в изменении с нашей стороны `пропса-in` для изменения внутреннего `state`.

`<TransitionGroup>` сам будет инициировать это изменение, а компоненты будут реагировать на это внутренними своей внутренней логикой и анимациями.

Обычно он используется в качестве обертки для нескольких компонентов, но может использоваться и для одного компонента. В этом случае изменение `пропа-key` дочернего компонента при измменении его контента заставит `<TransitionGroup>` выполнить его переход.

__Например:__ если на следующем рендере внутри `<TransitionGroup>` изменился список дочерних базовых компонентов, то есть добавился или удалился один из `<Transition>` или `<CSSTransition>` в следствии монтирования или размонтирования – `<TransitionGroup>` сделает свою работу и запустит у этих "добавившихся" или "убавившихся" компонентов внутреннюю логику переходов.

В приведенном ниже примере при удалении и добавлении задач в список, происходит автоматическое переключение `пропса-in` в `<TransitionGroup>`:
__[Пример работы](https://reactcommunity.org/react-transition-group/switch-transition](https://reactcommunity.org/react-transition-group/transition-group)__

__Обратите внимание:__ `<TransitionGroup>` не определяет анимацию. Анимирование элемента списка зависит от самого базового компонента перехода. А это значит, что с его помощью мы можем отслеживать и запускать анимации разных компонентов.

### Пропсы: 
* __`component`__ – по умолчанию `<TransitionGroup>` рендерится как `div`. Вы можете указать другой элемент или `null` (если хотите избежать рендеринга лишнего элемента);
* __`appear`__ – удобный проп для управления анимацией появления всех потомков. Обратите внимание, что определение данного пропа перезапишет соответствующие настройки дочерних компонентов;
* __`enter`__ - проп для управления анимацией вхождения всех потомков;
* __`exit`__ – проп для управления анимацией выхода всех потомков.
