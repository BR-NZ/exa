# Формы и валидация: Formik + Yup

__`Formik`__ — самая популярная библиотека для удобной работы с формами в `React` и `React Native`. Предоставляет валидацию, работу с событиями и собственные компоненты для форм с зашитой дополнительной функциональностью, таким образом, сокращает и избавляет от дублирования код.

По сути __библиотека реализована на кастомных хуках__, подобное можно реализовать и самому: данные формы в таком решении хранятся в рамках отдельного вызова функции, то есть в "замыкании".

Другим решением из сторонней библиотеки является хранение данных из формы в отдельном хранилище, например `Redux`. Но оно не слишком удачное, вызывает лишнии обновления и не подходит для средних и более проектов.

Более оптимизированная альтернатива: [`React-hook-form`](https://legacy.react-hook-form.com/ru)

<br>

## Установка
Установка прод-зависимости:  
```
npm i formik
```

Импортируем компоненты библиотеки в модуль, где их будем использовать:  
```javascript
import { Formik, Form, Field, ErrorMessage } from 'formik'
```

<br>

## Компонент `<Formik>`
* `<Formik>` — главный контролирующий компонент, весь функционал библиотеки находится в его пределах. Он должен возвращать `<form>` через рендер-функцию с множеством аргументов для работы внутри нее. Он связывается с элементами формы по их `name`-атрибуту.

### Пропсы `<Formik>`: 
* `initialValues` — содержит объект с начальными значениями элементов формы. Свойства объекта это `name`-атрибуты элементов формы, а значения свойств это их значения по умолчанию;
* `errors` — объект по структуре схожий с `initialValues`, его свойства это `name`-атрибуты элементов формы. Но в значениях он содержит ошибки для каждого элемента;
* `initialValues` — принимает функцию валидации значения элемента формы, она будет вызвана для каждого элемента формы при изменении его значения, текущее значение попадет в функцию валидации как аргумент, где его можно анализировать и предпринимать действия. Например, записать в объект `errors` ошибку для того или иного элемента формы.

<br>

## Типовой пример
Лучше всего понять принцип можно на общем примере:  
```javascript
const App = () => (
<Formik
   // объект с начальными значениями элементов формы (связь по атрибуту name)
   initialValues={{ email: '', password: '' }}
   
   // функция-валидатор вызывается при каждом срабатывании события "onChange"
   // получает текущее значение элемента
   validate={values => {
               const errors = {};
               if (!values.email) {
                    errors.email = 'Поле обязательно к заполнению';
               } else if (
                    !/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(values.email)
               ) {
                    errors.email = 'Некорректный адрес почты';
               }
               return errors;
   }}
   
   // вешаем колбек на события "submit" формы
   onSubmit={(values, { setSubmitting }) => {
                setTimeout(() => {
                    alert(JSON.stringify(values, null, 2));
                    setSubmitting(false);
                }, 400);
   }}
>

   // рендер-функция конфигурирует и отображает обычную форму
   // получает много полезных методов и значений
   {({ isSubmitting }) => (
                <Form>
                    // используем кастомные элементы библиотеки
                    <Field type="email" name="email" />
                    <ErrorMessage name="email" component="div" />
                    <Field type="password" name="password" />
                    <ErrorMessage name="password" component="div" />
                    <button type="submit" disabled={isSubmitting}>
                        Отправить
                    </button>
                </Form>
   )}
   
  </Formik>
);
```

<br>

## Готовые компоненты форм
Библиотека предоставляет собственные компоненты, реализующие привычные нам `HTML-элементы` форм: `Form`, `Field`, `ErrorMessage` и пр. Внутри них зашит весь функционал библиотеки, их применение существенно уменьшает дублирование и объем боилер-кода.

Можно использовать их стандартные прородители `HTML-элементы`: `form`, `input`, `textarea`, `option` и пр. Но в этом случае, стандартные элементы будет необходимо конфигурировать: задавать им обработчики для каждого нужного события и так далее.

### Пример
Легко понять их преимущества сравнив прошлый участок кода с данным:  
```javascript
const App = () => (
<Formik
   initialValues={{ email: '', password: '' }}
   validate={values => {
               const errors = {};
               if (!values.email) {
                    errors.email = 'Поле обязательно к заполнению';
               } else if (
                    !/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(values.email)
               ) {
                    errors.email = 'Некорректный адрес почты';
               }
               return errors;
   }}
   onSubmit={(values, { setSubmitting }) => {
                setTimeout(() => {
                    alert(JSON.stringify(values, null, 2));
                    setSubmitting(false);
                }, 400);
   }}
>
   // чтобы прокинуть все свойства и события стандартным элементам
   // мы вынуждены брать из объекта-аргумента больше функционала
   {({ values, errors, touched, handleChange, handleBlur, handleSubmit, isSubmitting }) => (
                <Form>
                    // так выглядит дублирование атрибутов каждому элементу
                    <input type="name" name="name" onChange={handleChange} onBlur={handleBlur} value={values.name} />
                    // а так вывод ошибок
                    { errors.name && touched.name %% errors.name }
                    <input type="email" name="email" onChange={handleChange} onBlur={handleBlur} value={values.email} />
                    { errors.email && touched.email && errors.email }
                    <button type="submit" disabled={isSubmitting}>
                        Отправить
                    </button>
                </Form>
   )}
   
  </Formik>
);
```
