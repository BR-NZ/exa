# Формы и валидация: Formik + Yup

__`Formik`__ — самая популярная библиотека для удобной работы с формами в `React` и `React Native`. Предоставляет валидацию, работу с событиями и собственные компоненты для форм с зашитой дополнительной функциональностью, таким образом, сокращает и избавляет от дублирования код.

По сути __библиотека реализована на кастомных хуках__, подобное можно реализовать и самому: данные формы в таком решении хранятся в рамках отдельного вызова функции, то есть в "замыкании".

Другим решением из сторонней библиотеки является хранение данных из формы в отдельном хранилище, например `Redux`. Но оно не слишком удачное, вызывает лишнии обновления и не подходит для средних и более проектов.

Более оптимизированная альтернатива: [`React-hook-form`](https://legacy.react-hook-form.com/ru)

<br>

## Установка
Установка прод-зависимостей:  
```
npm i formik
npm i yup
```

Импортируем компоненты библиотек в модуль, где их будем использовать:  
```javascript
import { Formik, Form, Field, ErrorMessage } from 'formik'
import { object, string, number, date, InferType } from 'yup'
```

### Действующие лица: 
* `initialValues` — содержит объект с начальными значениями элементов формы. Свойства объекта это `name`-атрибуты элементов формы, а значения свойств это их __значения по умолчанию__;
* `values` — объект по структуре схожий с `initialValues`, его свойства это `name`-атрибуты элементов формы. Но в значениях он __содержит текущее значение каждого элемента__;
* `errors` — объект по структуре схожий с `initialValues`, его свойства это `name`-атрибуты элементов формы. Но в значениях он __содержит ошибки для каждого элемента__;
* `validate` — функция валидации значений элементов формы, она будет вызвана для каждого элемента формы на событии `onChange` (при каждом изменении его значения). На вход она получает объект `values` с текущими значениями элементов, где его можно анализировать и предпринимать действия, например, записать в объект `errors` ошибку для того или иного элемента формы. Функцию стоит реализовать если мы не собираемся использовать сторонние инструменты валидации типа `Yup` или хотим ее дополнить.

<br>

## Варианты применения
Поскольку __библиотека реализована на кастомных хуках__, использовать ее можно двумя способами:  
* Используя ее через компонент `<Formik>` — предпочтительный вариант, так как использует контекст, а значит пробрасывать события элементам будет куда удобнее;
* Используя ее хук `useFormik()` — более незкоуровневый вариант если хочется "посмотреть под капот" библиотеки, кода и лишних действий будет больше;

<br>

## Готовые компоненты форм
Библиотека предоставляет собственные компоненты, реализующие привычные нам `HTML-элементы` форм: `Form`, `Field`, `ErrorMessage` и пр. Внутри них зашит весь функционал библиотеки, их применение существенно уменьшает дублирование и объем боилер-кода. __Они используют контекст `<Formik>` компонента__, чтобы незаметно получать и использовать внутри себя все события и объекты библиотеки, таким образом, передавать их явно в пропсы не нужно.

Компонент `Field` представляет наиболее общий компонент библиотеки, который заменяет собой стандартные элементы `input`, `textarea`, `select`, `checkbox`.

Можно использовать их стандартные прородители `HTML-элементы`: `form`, `input`, `textarea`, `select` и пр. Но в этом случае, стандартные элементы будет необходимо конфигурировать: задавать им обработчики для каждого нужного события и так далее (так как они не могут использовать контекст).

<br>

## 1. Используя компонент `<Formik>`
* __`<Formik>`__ — главный контролирующий компонент, весь функционал библиотеки находится в его пределах. Он должен возвращать `<form>` через рендер-функцию с множеством аргументов для работы внутри нее. Он связывается с элементами формы по их `name`-атрибуту.

### Пример `<Formik>` и "готовых" компонентов форм
Лучше всего понять принцип можно на общем примере:  
```javascript
const App = () => (
<Formik
   // объект с начальными значениями элементов формы (связь по атрибуту name)
   initialValues={{ email: '', password: '' }}
   
   // функция-валидатор вызывается при каждом срабатывании события "onChange"
   // получает текущее значение элемента
   validate={values => {
               const errors = {};
               if (!values.email) {
                    errors.email = 'Поле обязательно к заполнению';
               } else if (
                    !/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(values.email)
               ) {
                    errors.email = 'Некорректный адрес почты';
               }
               return errors;
   }}
   
   // вешаем колбек на события "submit" формы
   onSubmit={(values, { setSubmitting }) => {
                setTimeout(() => {
                    alert(JSON.stringify(values, null, 2));
                    setSubmitting(false);
                }, 400);
   }}
>

   // рендер-функция конфигурирует и отображает обычную форму
   // получает много полезных методов и значений
   {({ isSubmitting }) => (
                <Form>
                    // используем кастомные элементы библиотеки
                    <Field type="email" name="email" />
                    <ErrorMessage name="email" component="div" />
                    <Field type="password" name="password" />
                    <ErrorMessage name="password" component="div" />
                    <button type="submit" disabled={isSubmitting}>
                        Отправить
                    </button>
                </Form>
   )}
   
  </Formik>
);
```

### Пример `<Formik>` и "стандартных" элементов форм
Легко понять их преимущества сравнив прошлый участок кода с данным:  
```javascript
const App = () => (
<Formik
   initialValues={{ email: '', password: '' }}
   validate={values => {
               const errors = {};
               if (!values.email) {
                    errors.email = 'Поле обязательно к заполнению';
               } else if (
                    !/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(values.email)
               ) {
                    errors.email = 'Некорректный адрес почты';
               }
               return errors;
   }}
   onSubmit={(values, { setSubmitting }) => {
                setTimeout(() => {
                    alert(JSON.stringify(values, null, 2));
                    setSubmitting(false);
                }, 400);
   }}
>
   // чтобы прокинуть все свойства и события стандартным элементам
   // мы вынуждены брать из объекта-аргумента больше функционала
   {({ values, errors, touched, handleChange, handleBlur, handleSubmit, isSubmitting }) => (
                <Form>
                    // так выглядит дублирование атрибутов каждому элементу
                    <input type="name" name="name" onChange={handleChange} onBlur={handleBlur} value={values.name} />
                    // а так вывод ошибок
                    { errors.name && touched.name %% errors.name }
                    <input type="email" name="email" onChange={handleChange} onBlur={handleBlur} value={values.email} />
                    { errors.email && touched.email && errors.email }
                    <button type="submit" disabled={isSubmitting}>
                        Отправить
                    </button>
                </Form>
   )}
   
  </Formik>
);
```

<br>

## 2. Используя хук `useFormik()`
* __`useFormik()`__ — главный хук библиотеки, который и использует под капотом сам компонент `<Formik>`, получает на вход объект-конфигуратор с спец-объектами и обработчиками событий библиотеки. Вызов хука возвращает объект с другими спец-объектами и обработчиками событий, которые уже можно применять в рендере самой формы.

### Пример `useFormik()` и "стандартных" компонентов форм
Лучше всего понять принцип можно на общем примере:  
```javascript
const validate = values => { /* реализация уже приводилась выше */ }

const Form = () => {
    // хук получает на вход объект-конфигуратор
    const formik = useFormik({
        initialValues: {
            name: '',
            email: '',
            amount: 0,
            currency: 'USD',
            text: '',
            terms: false
        },
        validate,
        onSubmit: values => console.log(JSON.stringify(values, null, 2))
    });
    // а вернет объект со своими событиями и текущими значениями для элементов

    return (
        <form className="form" onSubmit={formik.handleSubmit}>
            <label htmlFor="name">Ваше имя</label>
            <input
                id="name"
                name="name"
                type="text"
                // значение каждого элемента отслеживается по объекту values
                // так реализуется двустороннее связывание у контролируемых элементов
                value={formik.values.name}
                // при изменении value элемента будет вызвана функция-обработчик handleChange
                // она будет смотреть с какими name изменился элемент и менять его значение в объекте values
                onChange={formik.handleChange}
                // onBlur сработает при потере элементом фокуса - и специальный объект touched по name ключу присвоит true
                // то есть в touched объекте поля помечаются как использованные
                // это нужно чтобы не выдывать предупреждений по неиспользованному пользователем полю
                onBlur={formik.handleBlur}
            />
            { formik.errors.name && formik.touched.name ? <div>{ formik.errors.name }</div> : null }
            
            <label htmlFor="currency">Валюта</label>
            <select
                // селект будет получать value из такого же атрибута у выбранного option
                id="currency"
                name="currency"
                value={formik.values.currency}
                onChange={formik.handleChange}
                onBlur={formik.handleBlur}>
                    <option value="">Выберите валюту</option>
                    <option value="USD">USD</option>
                    <option value="UAH">UAH</option>
                    <option value="RUB">RUB</option>
            </select>
            
            <label htmlFor="text">Ваше сообщение</label>
            <textarea 
                id="text"
                name="text" 
                value={formik.values.text}
                onChange={formik.handleChange}
                onBlur={formik.handleBlur}
            />
            
            <label className="checkbox">
                <input name="terms" type="checkbox" />
                Соглашаетесь с политикой конфиденциальности?
            </label>
            
            <button type="submit">Отправить</button>
        </form>
    )
}
```
Как видно, такой вариант применения библиотеки создает дублирование кода у усложняет понимание.

<br>

## Валидация с помощью `Yup`
* __`Yup`__ — библиотека для удобной валидации данных, может применяться отдельно от `Formik` или `React`. Проще говоря, это построитель `схемы` для анализа и проверки значений во время выполнения. Схема это тот шаблон, по которому данные будут валидированы, она поддерживает многоуровневую проверку и преобразование значений.

`Formik` также поддерживает получение пользовательских схем, для этого за место функции `validate` в ее компонент передается пропс `validationSchema` со специальным `yup-объектом` (для хука одноименное свойство объекта).

`Yup-схема` представляет собой объект, с `name-атрибутами` полей формы на месте свойств. Значения объекта-схемы заполняются особым способом: 
1. Сначала берем объект библиотеки `Yup` и вызываем на нем __метод типа данных__: `string()`, `number()`, `boolean()` и тд;
2. Далее на выбранном типе данных, который мы ожидаем у формы, по "chaining-принципу" можем вызывать различные методы проверок и преобразований;
3. Методы проверок и преобразований могут быть следующих типов: `mixed` (подходят для всех типов данных) и специализированные (типа `string`, `number`, `date` итд.);
4. То есть если ранее мы вызывали `string()` - можем вызывать методы из списка `string` или `mixed`, но не `number`;

### Пример создания схемы:
```javascript
import * as Yup from 'yup';

// создаем схему проверки условного объекта
// объект {values} - и будет в Formik этим объектом, где будут данные полей формы, которые стоит проверить
let userSchema = Yup.object({
   id: Yup.string().default('1').required(),
   names: yup.object({
    first: yup.string().default('Alex').min(2, 'Минимум 2 символа!').required(),
   }),
   email: Yup.string().email('Некорректный е-маил!').required('Обязательное поле!'),
});

// теперь на любом объекте-схеме можно вызвать методы:
// default() вернет объект со значениями указанными по умолчанию
userSchema.default() // -> {id: '1', names: {first: 'Alex'}}

// isValid( ..передав ему проверяемые данные )
// он будет проверен на соответствии правилам из схемы
userSchema.isValid( {id: 1} ) // -> false! names.first is required
```

### Пример c хуком`useFormik()` и `Yup-валидацией`:
```javascript
const Form = () => {
    const formik = useFormik({
        initialValues: {
            name: '',
            email: '',
            amount: 0,
            currency: 'USD',
            text: '',
            terms: false
        },
        // специальное свойство Formik для валидации через схему данных
        // Yup предоставит схему и будет проверять через нее объект { values } с текущими значениями формы
        // Yup также будет заполнять объект { errors } с ошибками для каждого элемента формы (в случае несоответствия его данных со схемой)
        validationSchema: Yup.object({
            name: Yup.string().min(2, 'Минимум 2 символа!').required('Обязательное поле!'), 
            email: Yup.string().email('Некорректный е-маил!').required('Обязательное поле!'),
        }),
        onSubmit: values => console.log(JSON.stringify(values, null, 2))
    });
```
