# React: Интересные моменты, установка

<br>

## Составляющие CRA

* `сreate-react-app (CRA)` – утилита React, создающая окружение, подключающая нужные npm-модули, создание начальной структуры приложения (отдельно устанавливать глобальный npm-пакет больше не нужно).
* `Webpack` – отвечает за сборку модулей в банлд, живую перезагрузку на сервере.
* `Babel` – минимизирует код, конвертирует код JS/JSX в старый стандарт JS с помощью плагина plugin-transform-react-jsx, он включен в пресет @babel/preset-react.

JSX (with Babel)	JS (with React)
<h1>Hello!</h1>;	React.createElement(‘h1’, {className: ‘class2..’}, ‘Hello!’);
Output (virtualDOM)	{ type: ‘h1’, props: {className: ‘class2’ children: ‘Hello!’} }

* `ESLint` – валидирует код реакт-компонентов, выводит сообщения в терминал.
* `WebVitals` – библиотека для измерения производительности приложения.
* `React (импорт-класс)` – отвечает за работу JSX и внутренних возможностей React.
* `ReactDOM (импорт-класс)` – позволяет работать с ДОМ-структурой на странице.

В 17 версии больше __не нужно подключать React/ReactDOM в каждый модуль__, теперь только во входном модуле с главным компонентом.

<br>

## Установка CRA
Чтобы развернуть шаблон начального проекта достаточно запустить:  
```
npx create-react-app [project_name] // запускаем в папке проектов
// в отличии от npm – npx позволяет запускать ремоут пакеты без установки
cd project_name // перемещаемся в папку проекта

npm start // скрипт запуска приложения и сервера
npm build // скрипт сборки приложения
```

Чтобы не создавать каждый компонент вручную:  
```
// спец-утилита создаст структуру готового компонента: папку и типовые файлы в ней, 
npx crcf src/components/error-indicator 

someComp
├── someComp.js
├── someComp.jsx
├── someComp.scss
└── someComp.js
```
<br>

## Моменты
* `Null`, `undefined` и прочие пустые значения не отображаются при рендере react-компонентов. 
* { Array } – отобразится склеяный массив. 
* { Object } – объекты нельзя вставлять на страницу, так как могут быть обработанны корректно в строку.

Каждом дочернему элементу в массиве, списке при рендере требуется установить свой key (id), это требует внутренний «механизм сравнения», для более быстрой отрисовки изменений в DOM.

Метод `Render` вызывается (перерисовывает), когда:
* Происходит вызов this.setState (изменяется State компонента)
* Изменяются входные свойства у комонента (Props)
Состояние нельзя менять напрямую, только через `this.setState()`: 
* Если новое состояние не зависит от предыдущего – просто передаем объект с новыми свойствам `{ ...states }`;
* Если новое состояние зависит от предыдущего – передаем каллбек (state) => {}, возвращающий объект с измененными свойствами;
Объект props есть у каждого компонента: его содержимое собирается из значений атрибутов переданных родительским компонентом. Сам компонент не может менять значение своих props (при изменении извне компонент будет перестроен).
События onChange и onInput работают одинаково (при вводе каждого символа).
Управляемые компоненты (контролируемые) – которые получают свое значения из state, при этом сами могут менять	 этот state. Неуправляемые компоненты хранят свое значение прямо в DOM, это не лучшее решение.
<React.Fragment> – позволяет обернуть несколько элементов в один контейнер для соблюдения правил JSX, без создания дополнительного видимого DOM-элемента, сам фрагмент в верстку не попадет (сокращенная запись <>…</>).
В коде можно использовать переменную окружения, она хранит адреса папок проекта, например: process.env.PUBLIC_URL
