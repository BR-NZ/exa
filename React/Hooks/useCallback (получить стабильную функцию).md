# ⌛ useCallback: вернет кэшированную функцию

## Зачем это:
__При передачи функций в качестве колбеков__ внешним компонентом через пропсы дочернему компоненту возникает проблема оптимизации: внешний компонент при следующем рендере пересоздаст тело функции, а значит изменит ссылку на нее в пропсе дочернего компонент, что неизбежно вызовет апдейт (рендер) дочернего компонент.

Чтобы этого избежать создают функции, __избегающие пересоздания (изменения ссылки) между рендерами__ содержащего их компонента – мемоизированные функции.

__`Мемоизированные функции`__ – такие функции стабильны пока значения из зависимостей неизменны. По факту, значения из зависимостей всегда должны использоваться в теле таких функций. Зависимости передаются в массиве, если передать пустой массив, функция никогда не будет пересоздана.

```javascript
const memoizedCallback = useCallback( () => {
    doSomething(a, b);
}, [a, b..] );

// Не создастся заново, пока `a` или `b` не изменятся
// Не вызовет апдейт получившего эту функцию компонента
```

Теперь, внутри дочернего компонента можно создавать эффект с привязкой зависимости к полученной из пропсов колбек-функции и не боятся что эффект будет ложно срабатывать всегда (просто из-за пересоздания функции и изменения ссылки на нее).

__Не имеет смысла использовать мемо-функцию внутри компонента__, где она создана (без передачи дочернему) – функция все равно будет всегда вызываться, нельзя привязать ее вызоваемость к равенству ссылки на нее.
