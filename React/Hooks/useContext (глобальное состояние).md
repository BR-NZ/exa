# React Context / useContext

Для простого __прокидывания данных дочерним компонентам__, минуя промежуточные, используют механизм глобального контекста по принципу «поставщика данных» и «потребителя» (слушателя поставщика). Такой подход позволяет избежать известной проблемы "сверления пропсов" - когда данные прокидываются через пропсы всех компонентов между поставщиком и потребителем.

<br>

## Создаем контекст: 
```javascript
// 1. Создаем объект контекста и устанавливаем ему значение по умолчанию
const someContext = React.createContext( defaultValue )

// 2. Вытаскиваем полезные компоненты Provider и Consumer из созданного объекта
const { Provider, Consumer } = someContext

// Сам объект контекста нам еще понадобится в компонентах-получателях
```

<br>

## Передаем данные контекста: 

__`<Provider value = "someValue">`__ - специальный компонент из объекта контекста, предоставляет «заданные» данные контекста из пропса `value` всем компонентам-потребителям ниже по дереву. Он __отслеживает изменение__ своих данных – это приводит к ререндеру всех компонентов-потребителей.

Если значение в пропсе `value` __не задано__, передаваться будет значение «по умолчанию», полученное при создании контекста.

```javascript
// Передаем данные внутри родительского компонента
// ... внутри render() или return() в классовом или функциональном

<Provider value = { значение_контекста }> 
  /* тут все компоненты-потребители */
</Provider>
```

<br>

## Получаем данные из контекста
Теперь в любом дочернем компоненте мы сможем получить данные из контекста

## В классовом компненте: 
__`<Consumer>`__ - специальный компонент из объекта контекста, получает данные от `Provider`, так как подписан на него. Также отслеживает изменения данных Provider и запускает ререндер своего компонента.

```javascript
// ВАРИАНТ 1: доступ к контексту сразу в render()
// <Consumer> содержит внутри колбек - получающий и отдающий значение контекста

<Consumer>
  { (value) => <h1>{ value }</h1> }
</Consumer>

// ВАРИАНТ 2: доступ к контексту через this.context
// Создаем классу компонента статическое свойство "contextType" - передаем туда созданный объект контекста

someClass.contextType = someContext // если вне класса
static contextType = someContext // если внутри класса
this.context // теперь экземпляру класса будет доступно значение контекста
```

### В функциональных компонентах:
```javascript
// Передаем специальному хуку созданный объект контекста
// Получаем переменную подписанную на изменение контекста (содержит его актуально значение)
const contextValue = React.useContext( someContext )
```

<br>

## Как изменять контекст в компоненте-потребителе
1.	Для этого в самом контексте создаем функцию, которая будет его изменять;
2.	Компонент-потребитель получаем и вызываем эту функцию;
3.	Контекст изменяется;

<br>

## Моменты: 
1. Контекст лучше выносить в отдельный модуль (импортируя куда нужно);
2. Создавать можно несколько контекстов под разные данные, тогда каждый из них передается отдельным <Provider> с пропсом value (вкладывая один в другой);
3. Контексты НЕ обязательно должны быть глобальными, контекст может и скорее всего, должен быть частью какой либо ветки компонентов в структуре приложения.
