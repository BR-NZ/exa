# React Context / useContext

Для простого прокидывания данных дочерним компонентам, минуя промежуточные, используют механизм глобального контекста по принципу «поставщика данных» и «потребителя» (слушателя поставщика).

```javascript
// 1. Создаем объект контекст и инициализируем значением по умолчанию
const someContext = React.createContext( defaultValue )

// 2. Вытаскиваем полезные компоненты Provider и Consumer
const { Provider, Consumer } = someContext

// 3. Передаем данные внутри render() или return()
<Provider value = значение_контекста> … компоненты-потребители </Provider>

// 4. Получаем данные из контекста в компоненте-потребителе

// 4.1 Классовый: 

// А.) Consumer получает колбек со значением контекста и отдает JSX-верстку
<Consumer> { (value) => <h1> value </h1> } </Consumer>

// В.) Задаем статическому свойству класса contextType значение контекста
someClass.contextType = someContext // вне класса
static contextType = someContext // внутри класса
this.context // теперь данные контекста доступны экземпляру класса

// 4.2 Функциональный:
// Подписываемся и получаем конекст с помощью простого хука
const contextValue = React.useContext( dataContext )
```

* __`<Provider value = “someValue”>`__ - специальный компонент из объекта контекста, предоставляет «заданные» данные контекста из пропса `value` всем компонентам-потребителям ниже по дереву.

`Provider` __отслеживает изменение__ своих данных – это приводит к ререндеру всех компонентов-потребителей.

Если значение в пропсе `value` __не задано__, передаваться будет значение «по умолчанию», полученное при создании контекста.

* __`<Consumer>`__ - специальный компонент из объекта контекста, получает данные от `Provider`, так как подписан на него. Также отслеживает изменения данных Provider и запускает ререндер своего компонента.

<br>

## Как изменять контекст в компоненте-потребителе
1.	В самом контексте должна быть функция, которая его изменяет;
2.	Компонент-потребитель получит и вызовет функцию, которая меняет контекст;

<br>

## Моменты: 
1.	Контекст лучше выносить в отдельный модуль (импортируя куда нужно);
2.	Создавать можно несколько контекстов под разные данные, тогда каждый из них передается отдельным <Provider> с пропсом value (вкладывая один в другой);
