# React Router: v5, v6

__`React Router`__ – библиотека маршрутизации между страницами (компонентами) внутри приложения.

<br>

## Импортируем:
```javascript
V5+
import { BrowserRouter as Router, Switch, Route, Link, NavLink } from “react-router-dom”
V6+
import { BrowserRouter as Router, Routes, Route, Link, NavLink } from “react-router-dom”
// импортируем ключевые сущности (компоненты) библиотеки
```

<br>

## Главный обработчик
* __`BrowserRouter`__ – главный компонент, отслеживающий всю работы с путями, внутри него помещают все пути и компоненты приложения, для использования роутинга. Он предоставляет `History API`.

__По умолчанию:__ роутер работает в режиме `композиции` и `неточных совпадений` путей. То есть сработают все пути имеюцие совпадение `подстроки с url-браузера` (но это поведение можно изменить).

<br>

## Контейнер путей

### В v5 версиях
* __`Switch`__ – специальный компонент оболочка, хранящий внутри пути, он работает по принципу первого неточного совпадения нашего url-браузера и одного из путей. 

### В v6 версиях
* __`Routes`__ – прешедшая на замену более мощная версия свитча, работает схоже, но: 
  * Все `Route` и `Link` внутри него __относительны__;
  * `Route` внутри него срабатывают __по наибольшему совпадению__, а не по порядку – то есть теперь пути можно размещать в любом порядке;
  * Поэтому, все пути можно отобразить в одном месте, вкладывая их друг в друга, а не разбрасывать по вложенным компонентам.

<br>

## Путь
* __`Route`__ – сам путь, это ключевой элемент, хранящий как свой путь (по которому он срабатывает), так и компонент приложения (который он должен отдать).

<br>

## Создание путей:

### В версиях V5
Cодержимые для отображения всегда между тэгов-путя:  
```javascript
<Route [exact] path="..путь"> <Компонент prop={ проп }/> </Route>
```
* Вложенные `Route` размещают внутри компонента-приложения, от которого идет путь.
* То есть внутри компонента внешнего Route, размещают дочерние `Route` с путем типа: `${match.url}/подпуть`.
* `exact` – опциональный атрибут, включает режим `"строгого равенства"` для путя, то есть он сработает только при полном равенстве с url-браузера.

### В версиях V6
Cодержимое для отображения в отдельном пропсе:  
```javascript
<Route path="..путь" element={ <Компонент prop={ проп }/> }/>
```
* Компонент приложения теперь хранится внутри `element-пропса`.
* `exact` – был удален за ненадобностью, благодаря новому алгоритму сравнения.

А между тэгов-путя теперь можно помещать вложенные пути:  
```javascript
<Route path="..путь" element={ <Компонент prop={ проп }/> }>
  <Route path="..путь1" element={ <Компонент prop={ проп }/> }/>
  <Route path="..путь2" element={ <Компонент prop={ проп }/> }/>
  
  <Outlet />
  // За место этого компонента-заглушки будут подгружаться компоненты из путей выше (при срабатывании)
</Route>
```
* `<Outlet />` – специальный компонент, его помещают во внешнем компоненте, на его месте и будут происходить рендеры дочерних `Route`.

### Пути с параметрами `/:param`
Бывает что при создании в `<Route />` мы сразу хотим обозначить что часть `url-строки` будет параметром, который, например, будет использоваться уже внутри отображаемого компонента.

__Вот как создается такой путь:__  
```javascript
// помещаем параметр в url-строки, помечая его ":" + имя параметра
<Route path="/user/:userId" element={ <Компонент /> }/>
```

__Теперь перейдем по ссылке:__ 
Чтобы вызвать срабатывание `<Route />` с определенным параметром, создадим `<Link />` с пропсом `to='user/111'`.

Все параметры из `url-строки` попадут в специальный объект, где ключи будут именами параметров, а значениями - реальная часть `url-строки`, которая расположилась в том месте где мы поместили параметр.  

__Cтруктура объекта-параметров будет:__  
```javascript
// допустим мы перешли по url: 
// site.ru/user/111 <- значение параметра

// получим такой объект
{ userId: 111, /* ..другие параметры из url * }
```

__Получаем объект параметров:__  
__`useParams()`__ - хук из библиотеки `React Router`, который получает объект с параметрами и их значениями из `url-строки`.
```javascrip
/* ..где-то внутри отображаемого <Route /> компонента */

const { userId } = useParams()
// получаем значение нашего параметра из url-строки из объекта
// используем его внутри компонента

fetch(`site.ru/users/${userId}`)
   .then(res => ...)

```

<br>

## Создание ссылок:

### Ссылки обычные `Link`
* __`Link`__ – аналог ссылки, рендерится в тег `<a href>`, его нажатие изменяет url-браузера, после чего срабатывает соответствующий `Route`.

### В версиях V5
В прошлой версии нужно следить за слэшами. Если находясь в `..url/user` кликаем на:  
* `<Link to="alex" />` - то есть без `/` в начале, попадем на `..url/alex` (путь замещается новым из ссылки);
* `<Link to="/alex" />` - а с `/` в начале, попадем на `..url/user/alex` (путь дополняется новым);

### В версиях V6
В `Route` ссылки всегда относительны: и мы в любом случае попадем на подпуть `..url/user/alex`;

Кроме того появились новые возможности:  
* `<Link to="." />` – url не изменится (останемся);
* `<Link to=".." />` – url сократится до / (уровень выше до родительского Route);
* `<Link to="../me" />` – url сократится до / и добавится me (на соседнюю);

<br>

### Ссылки с состоянием `Navlink`
* __`NavLink`__ – аналог `Link`, но с возможностью стилизации активного состояния (когда url-браузера совпадает с ним).

### В версиях V5
Имеет атрибуты установки активного стиля:  
```javascript
activeStyle = { color: “red” } ; 
activeClassName = ” active-class ” ;
```
* `exact` – атрибут для задания активности по строгому сравнению (а не подстроки).

### В версиях V6
Убраны атрибуты установки активного стиля. За место них в `style` и `className` передается колбек с флагов активности в аргументе:  
```javascript
style={ ({ isActive }) => ({color: isActive ? “red” : null}) }
className={ ({ isActive }) => isActive ? “active” : null }
```
* `exact` –> переименован в `end`.

<br>

## Редиректы
Компонент перенаправления на другой адрес, который можно помещать в условиях, в случае когда он им отдан.
### В версиях V5
```javascript
logged ? <Redirect to="/dashboard" /> : <PublicHomePage />
```
### В версиях V6
```javascript
<Route path="/redirect" element={ <Navigate to="/error-page" /> } />
```

<br>

## Другие моменты
* `useHistory (v5)` – хук, работающий с historyAPI, который управляет навигацией в браузере: переходы, замена и изменение истории переходов страниц.
* `useNavigate (v6)` – хук, работающий с historyAPI.
* `useRouteMatch (V5)` -> переименован в `useMatch (V6)`.

<br>

## React-router содержит 3 интересных объекта:
* `match` - для 
* `history` – для орагнизации переходов между страницами. Содержит методы goBack, goForward и пр.
* `location` – объект хранит состояние и положение нашего роутера.
