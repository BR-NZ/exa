# Основные принципы работы Redux

__`Redux`__ – менеджер состояний для управления состоянием данных и пользовательским интерфейсом в приложениях с большим количеством сущностей.

* `Redux` делает состояние глобальным для всего приложения;
* Состояние изолировано от прямых изменений в специальной сущности "хранилище";
* Оно доступно только для чтения, а все изменения возможны только по "заявке" к функции `reducer`.

<br>

## Reduce + Flux = Redux
Название «Редакс» составлено из двух слов: `reduce` и `flux`:
* `Reduce` — функция, которая приводит большую структуру данных к одному значению;
* `Flux` — архитектура приложения, при которой данные передаются в одну сторону.
Инструмент основан на этих двух понятиях, поэтому они вынесены в название.

<br>

## Использование
* Redux обычно используется в связке с фреймворками: React, Vue, Angular. Реже для проектов на чистом JS;
* Redux чаще всего используют с React, но его возможности не ограничиваются одной этой библиотекой;
* Имеет открытый исходный код и доступен бесплатно. Со всеми зависимостями __весит всего около 2 Кб__;
* Чаще всего в рамках приложения одно глобальное состояние, но технически количество не ограничено.

<br>

## Для чего нужен
* Для управления состоянием приложения, работающего с большим количеством данных;
* Более легкого масштабирования приложения, его преобразования под разные задачи;
* Избавления от ошибок, связанных с беспорядком в объекте состояния;
* Предсказуемости и понятности работы приложения.

<br>

## Как это работает
Принцип работы с состояниями в `Redux` хорошо отражена на анимированной схеме:

<img title="Анимация работы Redux" alt="Анимация работы Redux" width="600" src="https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif">

1. Допустим в `компоненте` (View, UI) произошло событие, которому нужно как-то изменить наше состояние, оно не сможет сделать это напрямую, только вызвав специальный метод-диспетчер `dispatcher`;
2. Метод `dispatcher` всегда принимает объект события (действия) `action`, внутри которого указывается как именно нам нужно изменить состояние;
  2.1 Объект `action` имеет один обязательный ключ `type` - он в виде строки и содержит тип действия над состоянием (его значения принято писать в верхнем регистре);
  2.2 Объект `action` также имеет один необязательный ключ `payload` - обычно, он содержит аргументы для обработчиков действия внутри `reducer()`;
3. Вызов `dispatcher()` из компонента на самом деле вызывает метод `reducer()` который получает на вход:
  3.1 Тот же объект действия `action` из диспетчера;
  3.2 А также текущее состояние приложения - для получения на его основе нового;
  
<br>

## 3 базовых принципа

### Единый источник состояния
Все данные о состоянии приложения хранятся в одном месте, без копий. Глобальное состояние организовано как дерево объектов и называется `state tree`. Также используются термины «источник состояния» и «хранилище». Оба означают местонахождение глобального состояния. Единый источник нужен для централизации и отладки приложения. Работа становится проще, если данные находятся в одном месте.

### Доступ к состоянию — только для чтения
Глобальное состояние заблокировано для записи и изменения. Компоненты приложения могут читать из него, но не переписывать по своему желанию. Это предотвращает непредсказуемые изменения. Ситуаций, когда объект изменился, а функции об этом не узнали, не бывает.

### Изменения — только через reduce()
Когда в состояние поступает действие, его обрабатывают "редукторы", или "редьюсеры" `reducers`. Это чистые функции — результат их выполнения зависит только от входных данных.

### Результат работы редуктора
Это новый объект состояния с актуальными данными, рассчитанными на основе информации из объекта-действия. Он попадает в дерево состояний вместо старого.
