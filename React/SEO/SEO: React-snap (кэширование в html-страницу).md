# React-snap: кэширование в html-страницу

Возвращаясь к проблеме SEO-оптимизации в SPA-приложениях, известно что поисковые роботы должны иметь возможность "путешествовать" по сайту, переходить по ссылкам и получать html-страницы с какой-либо структурой - этот процесс называется "индексированием".

Проблема в том, что любое SPA-приложение не отдает настоящих страниц браузеру, а заставляет браузер динамически собирать новые "страницы" в рамках существующей - `index.html`. А современные поисковые роботы поисковых систем плохо справляются с исполнением js-кода. Как итог, "дефолтное" SPA-приложение имее очень плохие показатели, ведь оно не индексируется. Для части проектов, где поисковая выдача не важна, это не является проблемой (например, админки и личные кабинеты). Для других есть сторонние решения.

__`React-snap`__ - (от слова `"snapshot"`) сторонняя библиотека для пререндера и кэширования полученных страниц всего SPA-приложения. Для этого она имеет встроенный `headless-браузер` (chromium движок без UI). Полученные странички она сохраняет в дирректории проекта, именно эти кэшированные версии будут отданы поисковому роботу.

<br>

## Преимущества: 
* Работает в проектах, основанных на разных SPA-технологиях;
* Не требует какого-либо конфигурирования проекта (изменений в логике);
* На борту использует реальный chromium-браузер со множеством оптимизаций производительности;
* Поддерживает AJAX-запросы: может кэшировать и динамический контект в том числе. 

<br>

## Установка 
### Устанавливаем как дев-зависимость:
```
npm i react-snap --save-dev
```

### Редактируем `package.json`: конфигурируем `react-snap`
```javascript
  "scripts": {
    // специальное имя скрипта 
    // позволит ему автоматически запускаться после каждого build
    "postbuild": "react-snap"
  }
  "reactSnap": {
    "source": "dist", // Каталог собранного приложения
    "destination": "dist", // Каталог для сохранения html-копий
    "include": [ // Список энтрипоинтов для обхода страниц
      "/",
      "/404",
      "/500"
      // …Другие необходимые энтрипоинты
    ]
  }
```

### Редактируем `src/index.js` (React 16.8+)
Для нормальной работы `React-приложения` у `обычного пользователя`, “поверх” DOM от web-сервера, нам потребуется внести небольшую правку в корневой render:
```javascript
// вытаскиваем новый метод hydrate
import { hydrate, render } from "react-dom";

// обычная корневая оболочка всего react-приложения
const rootElement = document.getElementById("root");

if (rootElement.hasChildNodes()) {
  // если отдается кэшированная react-snap страничка
  hydrate(<App />, rootElement)
  // цепляем наше react-приложение за этот DOM-скелет
} else {
  // а если отдана пустая страничка (ее нет в кеше)
  render(<App />, rootElement)
  // просто помещаем в нее react-приложение (как обычно) и он создаст DOM
}
```

<br>

## Как это работает: 
1. Мы закончили разработку приложения и запустили `bild` сборку продакшен версии, и готовы выполнить деплой на сервер;
2. Сразу после, автоматически будет запущен npm-скрипт `postbuild` библиотеки, в фоновом режиме начнет работу встроенный браузер;
3. Браузер пройдется по нашему приложению, используя наши `"точки входа"`, а дальше через ссылки `<a href>`;
4. Каждая полученная страница будет сохранена как настоящий `html-файл` в прод-папке `/dist` проекта.

### Результат: 
* В каталоге `/dist` мы получим тот же набор `index.html, js и css-файлов` (а также других ресурсов), что и раньше;
* Плюс к этому появятся `200.html` и можество `html-файлов` кэшированных копий страниц приложения.

<br>

## Моменты: 
* `React-snap` браузер видит только те __страницы, к которым ведут ссылки__ `<a>` с атрибутом `href`. Страницы, полученные в результате срабатывания событий, например, клика по элементу __кэшированы не будут__;

<br>

## Прочее: 
* __[Документация в Github](https://github.com/stereobooster/react-snap)__
* __[Классная статья на Habr](https://habr.com/ru/companies/rshb/articles/529636/)__
