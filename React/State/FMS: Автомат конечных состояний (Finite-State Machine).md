# FMS: Автомат конечных состояний (Finite-State Machine)

__`Автомат конечных состояний`__ — это подход к проектированию состояний и реагированию на его изменение, который помогает избежать путаницы и ошибок, когда `"глобальное"` состояние всей системы (компонента) в моменты времени зависит от сразу нескольких факторов `"под-состояний"`. 

Для этого конкретные `"глобальные"` состояния описываются в декларативном стиле: что при таком-то `"глобальном"` состоянии компонента, его `"под-состояния"` имеют такие-то значения. 

Такой подход позволяет сократить вариативность комбинаций `"под-состояний"`, которые могут незаметно произойти в ходе работы приложения, их сложно отследить в коде, и если подобная комбинация нами не была предусмотрена - получаем баг. 

Заранее описывая возможные `"глобальные"` состояния системы, с указанием соответствующим им значений `"под-состояний"`, решает эту проблему.

__Идея конечного автомата очень проста:__ компонент может находиться в одном из `"глобальных"` состояний, число которых ограничено.

> __Заметим:__ это не конкретная технология или готовое решение для определенной технологии, и не существует отдельной универсальной реализации для создания или перевода приложения на `"конечные состояния"`, в каждом случае решение может сильно различаться.

<br>

## Глобальные состояния
Значения для `"глобальных"` состояний принято назначать в виде строк в осмысленной форме, например: 
1. `waiting`;
2. `fetching`;
3. `loading`;
4. `resolve`;
5. `error`.
Это очевидно, ведь у "глобального" состояния может быть больше двух вариантов значений, а осмысленный вид упрощает отладку.

<br>

## Проблема
Допустим у нас есть компонент с текстовым полем для ввода и отображения значения и кнопкой подтверждения ввода:  

![Варианты состояния компонента](https://github.com/BR-NZ/synopsis/assets/24506129/c8ec98e0-82c3-42d6-8a98-d350d7c23528)

Возможные "состояния" такого компонента (слева направо):
1. Отображение значения;
2. Редактирование значения;
3. Отображение состояния при сохранении;
4. Отображение ошибки, возникшей при сохранении.

<br>

## Стандартный подход
В обычном варианте, состояние такого компонента мы бы описали 5 свойствами:  
```javascript
state: {
  processing: true, // true - при сохранении
  error: null,      // не null - когда возникла ошибка сохранения
  value: null,      // значение из текстового поля после подтверждения кнопкой (только для чтения)
  editValue: null,  // значение из текстового поля в момент редактирования (ещё не сохраненное)
  edition: false,   // true - в режиме редактирования
}
```
Лишь правильная комбинация значений у всех 5 свойств выдаст нам одно из 4 состояний из рисунка выше.

__Проблема:__  
Математически в ходе работы приложения и допущения ошибки в коде, такой `"state"` может принимать 2⁵ = 32 состояний. Таким образом у нас будет `32 - 4 = 28` ложных состояний, которые нам не нужны, но они могут получится при неправильном использовании свойств состояния. Но в больших приложениях и сложных компонентов, со множеством подобных свойств в состояние, бывает крайне сложно ими оперировать и гарантировать правильное использование и изменение в процессе работы.

<br>

## Новый подход
Используя подход с автоматом "конечных состояний", мы получим:  
```javascript
state: {
  display: {
    processing: false,
    error: null,
    value: "Awesome",
    edition: false,
    editValue: null,
  },
  saving: {
    processing: true,
    error: null,
    value: "Awesome",
    edition: true, // оставляем режим редактирования, пока значение сохраняется
    editValue: "Awesome Edit",
  },
  edit: {
    processing: false,
    error: null,
    value: "Awesome",
    edition: true,
    editValue: "Awesome Editing",
  },
  save_error: {
    processing: false,
    error: "Значение должно быть не короче 4 символов",
    value: "Awesome",
    edition: true, // оставляем окно редактирования открытым
    editValue: "Awe",
  }
}
```

__Отметим:__
* Да, описание состояний несколько разбухло;
* Легко понять состояние системы на каждом этапе (значении состояния);
* Легко расширять компонент, просто добавив новое состояние;
* Варианты состояний автомата (компонента) легко получать из макета дизайнера.

<br>

## Выводы
Использую новый подход при работе с состоянием, наше приложение должно оставаться гибким и обрабатывать непредвиденные сложности:
* [x] __Конечные автоматы__ — хороший способ улучшения читаемости ваших компонентов и процесса разработки этих компонентов от дизайна до поддержки;
* [ ] При использовании "конечных автоматов" увеличивается количество "шаблонного" кода для работы с сотоянием;
* [ ] __Не стоит использовать__ этот подход на простых компонентах, где и при стандартном подходе сложностей не возникало, это будет лишним усложнением;
* [ ] __Не стоит использовать__ этот подход на компонентах высокого уровня - количество состояний может быстро возрасти и такой подход не даст никакой пользы;

<br>

## Подробнее: 
* __[Хорошая статья с примерами](https://medium.com/devschacht/jean-paul-delimat-boost-your-react-with-state-machines-8a22885dc348)__
* __[Как в React избавиться от сложности в управлении состоянием](https://habr.com/ru/companies/nix/articles/354106/)__
* __[Конечный автомат: теория и реализация](https://tproger.ru/translations/finite-state-machines-theory-and-implementation/)__
