# FMS: Автомат конечных состояний (Finite-State Machine)

__`Автомат конечных состояний`__ — это подход к проектированию состояний и реагированию на его изменение, который помогает избежать путаницы и ошибок, когда `"глобальное"` состояние всей системы (компонента) в моменты времени зависит от сразу нескольких факторов `"под-состояний"`. 

Для этого конкретные `"глобальные"` состояния описываются в декларативном стиле: что при таком-то `"глобальном"` состоянии компонента, его `"под-состояния"` имеют такие-то значения. 

Такой подход позволяет сократить вариативность комбинаций `"под-состояний"`, которые могут незаметно произойти в ходе работы приложения, их сложно отследить в коде, и если подобная комбинация нами не была предусмотрена - получаем баг. 

Заранее описывая возможные `"глобальные"` состояния системы, с указанием соответствующим им значений `"под-состояний"`, решает эту проблему.

__Идея конечного автомата очень проста:__ компонент может находиться в одном из `"глобальных"` состояний, число которых ограничено.

> __Заметим:__ это не конкретная технология или готовое решение для определенной технологии, и не существует отдельной универсальной реализации для создания или перевода приложения на `"конечные состояния"`, в каждом случае решение может сильно различаться.

<br>

## Глобальные состояния
Значения для `"глобальных"` состояний принято назначать в виде строк в осмысленной форме, например: 
1. `waiting`;
2. `fetching`;
3. `loading`;
4. `resolve`;
5. `error`.
Это очевидно, ведь у "глобального" состояния может быть больше двух вариантов значений, а осмысленный вид упрощает отладку.

<br>

## Проблема
Допустим у нас есть компонент с текстовым полем для ввода и отображения значения и кнопкой подтверждения ввода:  

![Варианты состояния компонента](https://github.com/BR-NZ/synopsis/assets/24506129/c8ec98e0-82c3-42d6-8a98-d350d7c23528)

Возможные "состояния" такого компонента (слева направо):
1. Отображение значения;
2. Редактирование значения;
3. Отображение состояния при сохранении;
4. Отображение ошибки, возникшей при сохранении.

<br>

## Стандартный подход
В обычном варианте, состояние такого компонента мы бы описали 5 свойствами:  
```javascript
state: {
  processing: true, // true - при сохранении
  error: null,      // не null - когда возникла ошибка сохранения
  value: null,      // значение из текстового поля после подтверждения кнопкой (только для чтения)
  editValue: null,  // значение из текстового поля в момент редактирования (ещё не сохраненное)
  edition: false,   // true - в режиме редактирования
}
```
Лишь правильная комбинация значений у всех 5 свойств выдаст нам одно из 4 состояний из рисунка выше.

__Проблема:__  
Математически в ходе работы приложения и допущения ошибки в коде, такой `"state"` может принимать 2⁵ = 32 состояний. Таким образом у нас будет `32 - 4 = 28` ложных состояний, которые нам не нужны, но они могут получится при неправильном использовании свойств состояния. Но в больших приложениях и сложных компонентов, со множеством подобных свойств в состояние, бывает крайне сложно ими оперировать и гарантировать правильное использование и изменение в процессе работы.

<br>

## Новый подход
Используя подход с автоматом "конечных состояний", мы получим примерно следующую схему (не реализацию):  
```javascript
state: {
  display: {
    processing: false,
    error: null,
    value: "Awesome",
    edition: false,
    editValue: null,
  },
  saving: {
    processing: true,
    error: null,
    value: "Awesome",
    edition: true, // оставляем режим редактирования, пока значение сохраняется
    editValue: "Awesome Edit",
  },
  edit: {
    processing: false,
    error: null,
    value: "Awesome",
    edition: true,
    editValue: "Awesome Editing",
  },
  save_error: {
    processing: false,
    error: "Значение должно быть не короче 4 символов",
    value: "Awesome",
    edition: true, // оставляем окно редактирования открытым
    editValue: "Awe",
  }
}
```

## Пример реализации:
```javascript
class InputStateMachine extends Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.goToState = this.goToState.bind(this);
    this.save = this.save.bind(this);
    this.state = {
      name: 'display',
      machine: this.generateState('display', props.initialValue),
    };
  }
  
  generateState(stateName, stateParam) {
    const previousState = this.state ? {...this.state.machine} : {};
    switch (stateName) {
      case 'display':
        return {
          processing: false,
          error: null,
          value: stateParam || previousState.value,
          editing: false,
          editValue: null,
        };
      case 'saving':
        return {
          processing: true,
          error: null, // Сброс предыдущей ошибки сохранения
          value: previousState.value,
          editing: true, // Отображение окна редактирования в процессе сохранения
          editValue: previousState.editValue,
        };
      case 'edit':
        return {
          processing: false,
          error: null,
          value: previousState.value,
          editing: true,
          editValue: stateParam,
        };
      case 'save_error':
        return {
          processing: false,
          error: stateParam,
          value: previousState.value,
          editing: true, // Оставляем окно редактирования открытым
          editValue: previousState.editValue,
        };
      case 'loading': // Идентично состоянию по умолчанию
      default:
        return {
          processing: true,
          error: null,
          value: null,
          editing: false,
          editValue: null,
        };
    }
  }
  
  goToState(stateName, stateParam) {
    this.setState({
      name: stateName,
      machine: this.generateState(stateName, stateParam),
    });
  }
  handleSubmit(e) {
    this.goToState('edit', e.target.value);
  }
  save(valueToSave) {
    this.goToState('saving');
    // Имитируем сохранение данных...
    setTimeout(() => this.goToState('display', valueToSave), 2000);
  }
  
  render() {
    const {processing, error, value, editing, editValue} = this.state.machine;
    if (processing) {
      return <p>Processing ...</p>;
    } else if (editing) {
      return (
        <div>
          <input
            type="text"
            onChange={this.handleSubmit}
            value={editValue || value}
          />
          {error && <p>Error: {error}</p>}
          <button onClick={() => this.save(editValue)}>Save</button>
        </div>
      );
    } else {
      return (
        <div>
          <p>{value}</p>
          <button onClick={() => this.goToState('edit', value)}>Edit</button>
        </div>
      );
    }
  }
}
```

## Общие советы по реализации
При работе с конечными автоматами приходится писать немного шаблонного кода:  
1. Создайте утилитарный метод, который будет задавать название состояния и его содержимое. Позволяет легко получить текущее состояние и упрощает отладку компонента.
2. Сохраняйте метод, генерирующий состояние компонента, чистым и используйте его для генерации изначального состояния в конструкторе.
3. Используйте при деструктуризации `this.state.machine` вместо `this.state` в вашем методе `render()`.
4. Состоянию иногда необходимы параметры. Как правило, если ваше состояние требует более 3 параметров, вам не стоит использовать конечные автоматы в этом компоненте.

__Отметим:__
* Да, описание состояний несколько разбухло;
* Легко понять состояние системы на каждом этапе (значении состояния);
* Легко расширять компонент, просто добавив новое состояние;
* Варианты состояний автомата (компонента) легко получать из макета дизайнера.

<br>

## Выводы
Используя новый подход при работе с состоянием, наше приложение должно оставаться гибким и обрабатывать непредвиденные сложности:
* [x] __Конечные автоматы__ — хороший способ улучшения читаемости ваших компонентов и процесса разработки этих компонентов от дизайна до поддержки;
* [ ] При использовании "конечных автоматов" увеличивается количество "шаблонного" кода для работы с сотоянием;
* [ ] __Не стоит использовать__ этот подход на простых компонентах, где и при стандартном подходе сложностей не возникало, это будет лишним усложнением;
* [ ] __Не стоит использовать__ этот подход на компонентах высокого уровня - количество состояний может быстро возрасти и такой подход не даст никакой пользы;

<br>

## Подробнее: 
* __[Хорошая статья с примерами](https://medium.com/devschacht/jean-paul-delimat-boost-your-react-with-state-machines-8a22885dc348)__
* __[Как в React избавиться от сложности в управлении состоянием](https://habr.com/ru/companies/nix/articles/354106/)__
* __[Конечный автомат: теория и реализация](https://tproger.ru/translations/finite-state-machines-theory-and-implementation/)__
