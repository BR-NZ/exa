# Promise и Promise API
**Есть «создающий» код** – делающий что-то или получающий данные извне, мы не знаем как долго он будет выполняться. 
**Есть «потребляющий» код** – код, которому ему нужно получить результат создающего кода или сам факт его завершения. Он может совершать несколько действий.

Связать две части помогает объект-Promise – выполняющий `«создающий код»` помещается в функцию `«екзекутор»` и начинает исполняется сразу в момент создания объекта. 
```javascript
const promise = new Promise((resolve, reject) => { /* создающий код */ });
```
Далее, при завершении удачном или неочень, он должен вызывать одну из переданных ему колбек-функций resolve или reject, которые могут получить только один аргумент, который в дальнейшем будем передан по цепочке «слушателям».

Объект-промиса представлен упрощенно так:
```javascript
// он скрыт для изменений
{ state: ‘pending’, result: undefined } - изначально
{ state: ‘fulfilled’, state: value } – при вызове resolve()
{ state: ‘rejected’, result: error } – при вызове reject()
```

<br>

## Если в процессе промиса была вызвана:
resolve( data ) {} – будет исполнена первая конструкций then( data ) {}; 
Переданные в resolve( data ) параметр с данными попадут в блок then( data ) как аргумент, и он сможет продолжить с ним работу.
reject( error ) – будет исполнена первая catch( error ) {}
В случае ошибки, в reject( error ), рекомендуется передать объект-ошибки, он в свою очередь сразу попадет в ближайший блок catch( error ) { где ее можно как-то решить }
Блок обязательных действий finally():
Обычно его помещают в конце после всех then и catch блоков, он не принимает аргументов и не знает о исходе выполнения промиса, лишь служит местом выполнения действий, которые необходимо провести в любом случае (отчистка, тд).

<br>

## Цепочки слушателей «chaining»:
Блоков then после объекта-промиса может быть не один, а множество:
1.	Если блок `.then` в результате работы сам будет возвращать объект-промис;
2.	Если `.then` обычным синхронным кодом будет возвращать какой-то значение;
В любом случае, данные переданные функциям resolve / reject попадут ближним then / catch. Цепочка вызовов в свою очередь гарантирует очередность исполнения колбек-функций в их блоках.

<br>

## Полезные методы Promise API:
Класс Promise содержит несколько полезных статичных методов для работы с несколькими промисами. Все они возвращают получают на вход массив из промисов, но возвращают промис-объект с разными значениями.
`Promise.all( [ p1, p2 … ] )` – ждет __исполнения всех промисов__, и вернет массив с их результатами с сохранением их порядка.
`Promise.race( [ p1, p2 … ] )` – ждет выполнение только __самого быстрого промиса__, и вернет только его результат.
`Promise.any( [ p1, p2 … ] )` – ждет выполнение только __самого быстрого и успешного промиса__, и вернет только его результат.
Ко всем методам можно добавить цепочку слушаталей `then, catch, finally`. Которые будут получать на вход результаты работы этих методов.
