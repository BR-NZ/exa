# Promise и Promise API
* __Есть «создающий» код__ – делающий что-то или получающий данные извне, мы не знаем как долго он будет выполняться. 
* __Есть «потребляющий» код__ – код, которому нужно получить результат создающего кода или узнать сам факт его завершения.

Связать две части помогает объект-Promise – выполняющий `«создающий код»` помещается в функцию `«екзекутор»` и начинает исполняется сразу в момент создания объекта. 
```javascript
const promise = new Promise((resolve, reject) => { /* создающий код */ });
```
Далее, при завершении __удачном или неочень__, он должен вызывать одну из 2 переданных ему колбек-функций:
* __`resolve`__ - получает результат промиса, который передается ближайшему "слушателю" блоку `.then` и так далее..
* __`reject`__ - получает объект ошибки, который передается ближайшему "предохранителю" блоку `.catch`.

<br>

## Структура объекта-промиса
Объект-промиса представлен упрощенно так:  
```javascript
// свойства недоступны для работы и изменений
{ state: ‘pending’, result: undefined } // <- изначально (ожидает)
{ state: ‘fulfilled’, state: value } // <– при вызове resolve()
{ state: ‘rejected’, result: error } // <– при вызове reject()
```

<br>

## Варианты исхода промиса
Если в процессе промиса была вызвана:
* __`resolve( data )`__ – успех, будет исполнена первая конструкция then( data => {} ), то есть и переданные в `resolve` параметр `data` с результатом попадут в блок `then` как аргумент, и он сможет продолжить с ним работу.
* __`reject( error )`__ – ошибка, будет исполнена первая конструкция catch( error => {} ), в `reject`, рекомендуется передать объект-ошибки, он в свою очередь попадет в ближайший блок `catch` для обработки.

<br>

## Блок обязательных действий `finally()`:
Служит местом выполнения действий, которые необходимо провести при любом исходе, например отчистка, отписка от событий, разрыв соединений и тд.

* Он не принимает аргументов и не знает о исходе выполнения промиса
* Он ничего не возвращает или это будет проигнорированно
* Если он будет расположен перед `then` или `catch` блоком, он пропустит мимо себя их аргументы
* Если внутри него произойдет ошибка - она всплывает в ближайшем обработчике ошибок

Обычно его помещают в конце после всех `then` и предед или до `catch` блока.

<br>

## Цепочки слушателей «chaining»:
Блоков `then` после объекта-промиса может быть множество, вместе с `catch` и `finally` они образуют "цепочку слушателей":

1.	Если блок `.then` в результате работы возвращает __обычное значение__ - это значение попадет на вход следущему блоку
2.	Если блок `.then` хочет выполнить __асинхронную операцию__, он должен создать и вернуть новый промис - его результат также передастся по цепочке

```javascript
new Promise(function(resolve, reject) {
  setTimeout(() => resolve(1), 1000);
}).then(function(result) {
  alert(result); // 1
  return new Promise((resolve, reject) => { // (*)
    setTimeout(() => resolve(result * 2), 1000);
  });
}).then(function(result) { // (**)
  alert(result); // 2
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(result * 2), 1000);
  });
})
```

Цепочка вызовов очередь гарантирует очередность исполнения колбек-функций в их блоках.

<br>

## Полезные методы Promise API:
Класс `Promise` содержит несколько полезных статичных методов для работы с несколькими промисами. Все они возвращают получают __на вход массив из промисов__, но __возвращают промис-объект с разными значениями__.

* `Promise.all( [ p1, p2 … ] )` – ждет __исполнения всех промисов__, и вернет массив с их результатами с сохранением их порядка.
* `Promise.race( [ p1, p2 … ] )` – ждет выполнение только __самого быстрого промиса__, и вернет только его результат.
* `Promise.any( [ p1, p2 … ] )` – ждет выполнение только __самого быстрого и успешного промиса__, и вернет только его результат.

Ко всем методам можно добавить цепочку слушаталей `then, catch, finally`. Которые будут получать на вход результаты работы этих методов.
