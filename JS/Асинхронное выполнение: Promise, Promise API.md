# Promise и Promise API
* __Есть «создающий» код__ – делающий что-то или получающий данные извне, мы не знаем как долго он будет выполняться. 
* __Есть «потребляющий» код__ – код, которому нужно получить результат создающего кода или узнать сам факт его завершения.

Связать две части помогает объект-Promise – выполняющий `«создающий код»` помещается в функцию `«екзекутор»` и начинает исполняется сразу в момент создания объекта. 
```javascript
const promise = new Promise((resolve, reject) => { /* создающий код */ });
```
Далее, при завершении __удачном или неочень__, он должен вызывать одну из 2 переданных ему колбек-функций:
* __`resolv`__ - получает результат промиса, который передается ближайшему "слушателю" блоку `.then` и так далее..
* __`reject`__ - получает объект ошибки, который передается ближайшему "предохранителю" блоку `.catch`.

<br>

## Структура объекта-промиса
Объект-промиса представлен упрощенно так:  
```javascript
// он скрыт для изменений
{ state: ‘pending’, result: undefined } // <- изначально (ожидает)
{ state: ‘fulfilled’, state: value } // <– при вызове resolve()
{ state: ‘rejected’, result: error } // <– при вызове reject()
```

<br>

## Варианты исхода промиса
Если в процессе промиса была вызвана:
* __`resolve( data )`__ – успех, будет исполнена первая конструкция then( data => {} ), то есть и переданные в `resolve` параметр `data` с результатом попадут в блок `then` как аргумент, и он сможет продолжить с ним работу.
* __`reject( error )`__ – ошибка, будет исполнена первая конструкция catch( error => {} ), в `reject`, рекомендуется передать объект-ошибки, он в свою очередь попадет в ближайший блок `catch` для обработки.

<br>

## Блок обязательных действий `finally()`:
Обычно его помещают в конце после всех `then` и `catch` блоков, он не принимает аргументов и не знает о исходе выполнения промиса, лишь служит местом выполнения действий, которые необходимо провести при любом исходе, например отчистка, отписка от событий и тд.

<br>

## Цепочки слушателей «chaining»:
Блоков `then` после объекта-промиса может множество, вместе с `catch` и `finally` они образуют "цепочку слушателей":
1.	Если блок `.then` в результате работы сам будет возвращать объект-промис;
2.	Если `.then` обычным синхронным кодом будет возвращать какой-то значение;
В любом случае, данные переданные функциям resolve / reject попадут ближним then / catch. Цепочка вызовов очередь гарантирует очередность исполнения колбек-функций в их блоках.

<br>

## Полезные методы Promise API:
Класс `Promise` содержит несколько полезных статичных методов для работы с несколькими промисами. Все они возвращают получают __на вход массив из промисов__, но __возвращают промис-объект с разными значениями__.

* `Promise.all( [ p1, p2 … ] )` – ждет __исполнения всех промисов__, и вернет массив с их результатами с сохранением их порядка.
* `Promise.race( [ p1, p2 … ] )` – ждет выполнение только __самого быстрого промиса__, и вернет только его результат.
* `Promise.any( [ p1, p2 … ] )` – ждет выполнение только __самого быстрого и успешного промиса__, и вернет только его результат.

Ко всем методам можно добавить цепочку слушаталей `then, catch, finally`. Которые будут получать на вход результаты работы этих методов.
