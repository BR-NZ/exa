# Promise и Promise API
* __Есть «создающий» код__ – например, помещенный в функцию `"экзекутор"` и делающий что-то или получающий данные извне, мы не знаем как долго он будет выполняться. 
* __Есть «потребляющий» код__ – код, которому нужно получить результат создающего кода или узнать сам факт его завершения.

Связать две части помогает объект-Promise – специальный объект, выполняющий `«создающий код»` в переданной функции `«екзекуторе»` и передающий результат (по готовности) своим `"слушателям"`. 
```javascript
const promise = new Promise((resolve, reject) => { /* создающий код */ });
```
Далее, при завершении __удачном или неочень__, он должен вызывать одну из 2 переданных ему колбек-функций:
* __`resolve`__ - получает результат промиса, который передается ближайшему "слушателю" блоку `.then` и так далее..
* __`reject`__ - получает объект ошибки, который передается ближайшему "предохранителю" блоку `.catch`.

<br>

## Структура объекта-промиса
Объект-промиса представлен упрощенно так:  
```javascript
{ state: ‘pending’, result: undefined } // <- изначально (ожидает)
{ state: ‘fulfilled’, state: value } // <– при вызове resolve (выполнен успешно)
{ state: ‘rejected’, result: error } // <– при вызове reject (выполнен с ошибкой)
```
Свойства объекта-промиса недоступны для работы и изменений, мы можем с ними работать только через `then`, `catch`, `finally`.

<br>

## Варианты исхода промиса
Если в процессе промиса была вызвана:
* __`resolve( data )`__ – успех, будет исполнена первая конструкция then( data => {} ), то есть и переданные в `resolve` параметр `data` с результатом попадут в блок `then` как аргумент, и он сможет продолжить с ним работу.
* __`reject( error )`__ – ошибка, будет исполнена первая конструкция catch( error => {} ), в `reject`, рекомендуется передать объект-ошибки, он в свою очередь попадет в ближайший блок `catch` для обработки.

<br>

## Блок обязательных действий `finally()`:
Служит местом выполнения действий, которые необходимо провести при любом исходе, например отчистка, отписка от событий, разрыв соединений и тд.

* Он не принимает аргументов и не знает о исходе выполнения промиса;
* Он ничего не возвращает или это будет проигнорированно;
* Если он будет расположен перед `then` или `catch` блоком, он пропустит мимо себя их аргументы;
* Если внутри него произойдет ошибка - она всплывает в ближайшем обработчике ошибок;

Обычно его помещают в конце после всех `.then` и перед или до `.catch` блоков.

<br>

## Цепочки слушателей «chaining»:
Блоков `then` после объекта-промиса может быть множество, вместе с `catch` и `finally` они образуют "цепочку слушателей":
```javascript
new Promise(function(resolve, reject) {
  setTimeout(() => resolve(1), 1000);
}).then(function(result) {
  alert(result); // 1
  return new Promise((resolve, reject) => { // (*)
    setTimeout(() => resolve(result * 2), 1000);
  });
}).then(function(result) { // (**)
  alert(result); // 2
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(result * 2), 1000);
  });
})
```
1.	Если блок `.then` в результате работы возвращает __обычное значение__ - это значение попадет на вход следущему блоку;
2.	Если блок `.then` хочет выполнить __асинхронную операцию__, он должен создать и вернуть новый промис - следующие обработчики в цепочке ждут его выполнения, а результат промиса также передастся по цепочке;

Цепочка вызовов гарантирует очередность исполнения колбек-функций в их блоках. Все обработчики будут выполнены в одном цикле событий сразу - это гарантирует неизменность окружения в процессе их выполнения.

<br>

## Полезные методы Promise API:
Класс `Promise` содержит несколько полезных статичных методов для работы с несколькими промисами. Все они возвращают получают __на вход массив из промисов__, но __возвращают промис-объект с разными значениями__.

* `Promise.all( [ p1, p2 … ] )` – ждет __исполнения всех промисов__, и вернет массив с их результатами с сохранением их порядка и их статус исполнения (если все успешны). Но если хоть один из промисов будет отклонен, вернется его аргумент reject и его статус отклоненного.
* `Promise.race( [ p1, p2 … ] )` – ждет выполнение только __самого быстрого промиса__, и вернет только его результат.
* `Promise.any( [ p1, p2 … ] )` – ждет выполнение только __самого быстрого и успешного промиса__, и вернет только его результат.

Ко всем методам можно добавить цепочку слушаталей `then, catch, finally`. Которые будут получать на вход результаты работы этих методов.
