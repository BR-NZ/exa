# Событийный цикл `Event Loop`
`Event Loop` - это специальный механизм на уровне js-движка, который координирует работу трёх сущностей: `Call Stack` (стэк вызовов), `Web API` (API, предоставляемый браузером), `Callback Queue` (очередь колбэков). По сути, это бесконечная «карусель», которая исполняет задачи __для 3 "заказчиков__: 

1.  `Browser API` отслеживает срабатывание таймаутов, интервалов и DOM-событий на стороне браузера. По мере срабатывания их коллбеки помещаются в очередь `макрозадач` и `микрозадач`

    1.2  `Макротаски (tasks queue)` – этот тип задача попадает в очередь макро-задач и выполняются из нее по 1й задаче за цикл.

    *	setTimeot / setInterval
    *   console.log
    *   запуск <script>
    *	синхронный код

    1.3  `Микротаски (microstasks queue)` – попадают в очередь микрозадач и выполняются все сразу, то есть другие задачи в промежутках между ними не обрабатываются, это гарантирует неизменность окружения в процессе выполнения микрозадач. Но, если время их выполнения меньше или равно времени появления новых - они могут выполняться вечно.

    *   обработчики промисов: .then, .catch, .finally, await (их коллбеки)
    *	mutation observer

3.  Render API отрисовывает изменения, этот этап оптимизируется браузером - если изменений нет, он пропускается

<br>

## Cхема работы

<img width="650" title="Event Loop" alt="Event Loop" src="https://github.com/BR-NZ/synopsis/assets/24506129/f6ec25ec-25a2-407e-ae7e-99f79761f18f">

<br>
<br>

* `Callstack (стэк вызовов)` - как видно из схемы, это единственное место из которого задачи идут на исполнение, задачи в нем выполняются по принципу стэка LIFO (то есть выполняются самые свежие, старые ждут).
* `Event Loop (цикл событий)` - это тот самый барабан, который решает какие задачи и из какой очереди запустить в `Callstack` к выполнению.
* `Callback Queue (очередь колбэков)` - по сути это 3 очереди из 3 типов задач: микро, макро и рендер. Из них цикл событий по определенному приоритету берет задачи и помещает в `Callstack` и исполняет.

<br>
    
<img width="650" title="Event Loop" alt="Event Loop" src="https://github.com/BR-NZ/synopsis/assets/24506129/450730cd-7ba3-42e2-a1ba-ae205e287373">

<br>
<br>
  
## Алгоритм
Приоритет к выполнению в "цикле событий" всегда имеют макро-задачи. Но такой задачей можеть стать простой запуск скрипта. И тогда первой к выполнению уже внутри скрипта будет очередь микро-задач (все сразу).
0.  Выбрать и исполнить старейшую задачу из очереди макро-задач (например, "run script")
1.  Выполнить все задачи из очереди микро-задач (пока не пуста) 
2.	Выбрать из очереди и исполнить "старейшую" микро-задачу
3.	Отрисовать изменения страницы (если они есть)
4.	Если очередь макро-задач пуста – подождать, пока появится макро-задача
5.	Перейти к шагу 0

<br>

## На словах
__Работают они следующим образом:__ js-движок анализирует код. Когда он встречает вызов какой-то функции, он перемещает эту функцию в `Call Stack`. Если эта функция синхронная (например, `console.log()`), то она сразу же исполняется, покидает стэк и на её место приходит следующая функция. Если же эта функция асинхронная, например, `setTimeout()`, обработчик событий, сетевой запрос и т.д., то на помощь приходит браузер со своим `Web API` (мы же помним, что JavaScript - это однопоточный язык, и сам работать в многопоточном режиме он не может). `Event Loop` перемещает колбэк асинхронной функции в `Web API`, а сама асинхронная функция уходит из стэка вызовов. То есть, пока колбэк асинхронной функции находится под управлением `Web API`, js-движок продолжает выполнять другие операции!

Что же происходит с колбэком? В случае, например, `setTimeout()`, Web API ожидает истечения указанного времени, затем Event Loop перемещает этот колбэк в `Callback Queue` (очередь колбэков). Когда стэк вызовов освобождается, Event Loop перемещает в него наш колбэк из очереди колбэков, после чего колбэк наконец исполняется и покидает стэк вызовов.
    
<br>

## Для разбиения крупной макро-задачи на несколько:
Используйте setTimeout(f) с нулевой задержкой. Это даст пространство для исполнения других участников цикла: микро-задач, рендер и пр.

<br>

## Для добавления в очередь новой микро-задачи:
Используйте queueMicrotask(f) – асинхронно выполнит функцию в том же состоянии окружения.
  
__[Демонстрация работы цикла](http://latentflip.com/loupe)__
