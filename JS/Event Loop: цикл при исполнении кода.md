# Событийный цикл `Event Loop`
`Event Loop` - это специальный механизм на уровне js-движка, который координирует работу трёх сущностей: `Call Stack` (стэк вызовов), `Web API` (API, предоставляемый браузером), `Callback Queue` (очередь колбэков). По сути, это бесконечная «карусель», которая исполняет задачи __для 3 "заказчиков__: 

1.  `Browser API` отслеживает срабатывание таймаутов, интервалов и событий. По мере срабатывания их коллбеки помещаются в очередь `макрозадач` и `микрозадач`

1.2  `Макротаски (tasks queue)` – очередь макро-задач, выполняются по 1й задаче за цикл.
__К ним относятся:__
*	setTimeot / setInterval
* console.log
* запуск <script>
*	синхронный код

1.3  `Микрозадачи (microstasks queue)` – выполняются все сразу и другие задачи в промежутках между ними не обрабатываются, это гарантирует неизменность окружения в процессе выполнения микрозадач. Но, если время их выполнения меньше или равно времени появления новых - они могут выполняться вечно.
__К ним относятся:__
* обработчики промисов: .then, .catch, .finally (их коллбеки)
*	await (код после)

3.  Render API отрисовывает изменения, этот этап оптимизируется браузером - если изменений нет, он пропускается

<img width="650" title="Event Loop" alt="Event Loop" src="https://github.com/BR-NZ/synopsis/assets/24506129/f6ec25ec-25a2-407e-ae7e-99f79761f18f">

<br>
  
## Алгоритм
Приоритет к выполнению в "цикле событий" всегда имеют макро-задачи. Но такой задачей можеть стать простой запуск скрипта. И тогда первой к выполнению уже внутри скрипта будет очередь микро-задач (все сразу).
0.  Выбрать и исполнить старейшую задачу из очереди макро-задач (например, "run script")
1.  Выполнить все задачи из очереди микро-задач (пока не пуста) 
2.	Выбрать из очереди и исполнить "старейшую" микро-задачу
3.	Отрисовать изменения страницы (если они есть)
4.	Если очередь макро-задач пуста – подождать, пока появится макро-задача
5.	Перейти к шагу 0

<br>

## Для разбиения крупной макро-задачи на несколько:
Используйте setTimeout(f) с нулевой задержкой. Это даст пространство для исполнения других участников цикла: микро-задач, рендер и пр.

<br>

## Для добавления в очередь новой микро-задачи:
Используйте queueMicrotask(f) – асинхронно выполнит функцию в том же состоянии окружения.
  
__[Демонстрация работы цикла](http://latentflip.com/loupe)__
