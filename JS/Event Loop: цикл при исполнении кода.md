# Событийный цикл `Event Loop`
Код каждой HTML-страницы в браузере выполняется в __Main Thread__. `Main Thread` — это основной поток, где браузер выполняет JS-код, делает перерисовки, обрабатывает пользовательские действия и многое другое. По сути, это то место, где движок JS интегрирован в браузер.

__Вот упрощенная схема:__  
<img width="650" title="Event Loop" alt="Event Loop" src="https://github.com/BR-NZ/synopsis/assets/24506129/f6ec25ec-25a2-407e-ae7e-99f79761f18f">
<br>
<br>
То есть у нас есть поставщики (или "заказчики исполнения") задач - `Browser API` и `Render API`. Каждый из них заполняет очереди из своего типа задач. И координатор между ними, который решает из какой очереди и в каком количестве задачи передать на исполнение - `Event Loop`. Единственный их исполнитель - `Callstack`.

<br>

## Участники
*  __`Browser API`__ – окружение браузера отслеживает срабатывание таймаутов, интервалов и DOM-событий на стороне браузера. По мере срабатывания их коллбеки помещаются в очередь `макрозадач` и `микрозадач`:  

* __`Макротаски (tasks queue)`__ – этот тип задача попадает в очередь макро-задач и выполняются из нее по 1й задаче за цикл.

    * SetTimeot и setInterval
    * Console.log
    * Запуск <script>
    *	Синхронный код

*  __`Микротаски (microstasks queue)`__ – попадают в очередь микрозадач, они выполняются все сразу, то есть другие задачи в промежутках между ними не обрабатываются, это гарантирует неизменность окружения в процессе выполнения микрозадач. Но, если время их выполнения <= времени появления новых - они могут выполняться вечно.

    * Обработчики промисов: .then, .catch, .finally, await (то есть все их коллбеки будут обработаны за раз)
    *	Mutation Observer (отслеживатель изменения DOM-элементов)

*  __`Render API`__ – среда браузера отрисовывает изменения, этот этап оптимизируется браузером и если изменений нет, он пропускается.

<br>

## Cхема работы
<img width="650" title="Event Loop" alt="Event Loop" src="https://github.com/BR-NZ/synopsis/assets/24506129/450730cd-7ba3-42e2-a1ba-ae205e287373">
<br>
<br>
  
## Алгоритм
__Приоритет к выполнению__ в "цикле событий" всегда имеют `макро-задачи`. Но такой задачей можеть стать простой запуск скрипта. Поэтому получается, что __первой к выполнению уже внутри скрипта__ будет очередь `микро-задач`.
1. Выбрать и исполнить старейшую задачу из очереди макро-задач. Если очередь макро-задач пуста – подождать, пока появится макро-задача (например, `run script`).
2. Выполнить все задачи из очереди микро-задач (например, .then и выполнить их все пока не пуста).
3.	Отрисовать изменения страницы (если они есть)
4.	Перейти к шагу 1

<br>

## На словах и подробнее
__Работают они следующим образом:__ js-движок анализирует код. Когда он встречает вызов какой-то функции, он перемещает эту функцию в `Call Stack`. Если эта функция синхронная (например, `console.log()`), то она сразу же исполняется, покидает стэк и на её место приходит следующая функция. Если же эта функция асинхронная, например, `setTimeout()`, обработчик событий, сетевой запрос и т.д., то на помощь приходит браузер со своим `Web API` (мы же помним, что JavaScript - это однопоточный язык, и сам работать в многопоточном режиме он не может). `Event Loop` перемещает колбэк асинхронной функции в `Web API`, а сама асинхронная функция уходит из стэка вызовов. То есть, пока колбэк асинхронной функции находится под управлением `Web API`, js-движок продолжает выполнять другие операции!

Что же происходит с колбэком? В случае, например, `setTimeout()`, Web API ожидает истечения указанного времени, затем Event Loop перемещает этот колбэк в `Callback Queue` (очередь колбэков). Когда стэк вызовов освобождается, Event Loop перемещает в него наш колбэк из очереди колбэков, после чего колбэк наконец исполняется и покидает стэк вызовов.
    
<br>

## Для разбиения крупной макро-задачи на несколько:
Используйте setTimeout(f) с нулевой задержкой. Это даст пространство для исполнения других участников цикла: микро-задач, рендер и пр.

<br>

## Для добавления в очередь новой микро-задачи:
Используйте queueMicrotask(f) – асинхронно выполнит функцию в том же состоянии окружения.
  
__[Демонстрация работы цикла](http://latentflip.com/loupe)__
