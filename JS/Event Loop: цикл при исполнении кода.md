# Событийный цикл `Event Loop`
`Event Loop` - это специальный механизм на уровне js-движка, который координирует работу трёх сущностей: `Call Stack` (стэк вызовов), `Web API` (API, предоставляемый браузером), `Callback Queue` (очередь колбэков).
Это бесконечная «карусель», которая собирает задачи __из 3 очередей__: `макро` и `микро задач`.

<img width="650" title="Event Loop" alt="Event Loop" src="https://github.com/BR-NZ/synopsis/assets/24506129/f6ec25ec-25a2-407e-ae7e-99f79761f18f">

## Последовательность задач
Задачи выполняются в следующей последовательности:

1.	`Макротаски (tasks queue)` – очерель макро-задач, выполняются по 1й задаче за цикл.
К ним относятся: 
*	setTimeot / setInterval
* console.log
* запуск <script>
*	синхронный код

2.	`Web API (Node)` отслеживает срабатывание таймаут, интервал или события. По мере срабатывания их коллбеки помещаются в очередь макрозадач.

3.	`Микрозадачи (promise jobs)` выполняются все сразу, хранятся в «очереди» (LIFO). Другие задачи в промежутках между микро-задачами не отрабатываются, это гарантирует неизменность окружения в процессе выполнения микрозадач.
* .then.catch.finally (их коллбеки)
*	await (код после)

2. Микро-таск – выполняются все сразу, хранятся в «очереди» (LIFO). Другие задачи в промежутках между микро-задачами не отрабатываются, это гарантирует неизменность окружения в процессе выполнения микрозадач.
-	
3. Рендер – отрисовка изменений в браузере.
4. Web APIs – периодически задачи в очередь подкидывает браузер, который ответственен за работу setTimeout, setInterval, Events и отслеживание необходимости выполнения переданных им каллбеков.

## Алгоритм
Приоритет к выполнению в "цикле событий" всегда имеют макро-задачи. Но такой задачей можеть стать простой запуск скрипта. И тогда первой к выполнению уже внутри скрипта будет очередь микро-задач (все сразу).
0.  Выбрать и исполнить старейшую задачу из очереди макро-задач (например, "run script")
1.  Выполнить все задачи из очереди микро-задач (пока не пуста) 
2.	Выбрать из очереди и исполнить "старейшую" микро-задачу
3.	Отрисовать изменения страницы (если они есть)
4.	Если очередь макро-задач пуста – подождать, пока появится макро-задача
5.	Перейти к шагу 0

<br>

## Для разбиения крупной макро-задачи на несколько:
Используйте setTimeout(f) с нулевой задержкой. Это даст пространство для исполнения других участников цикла: микро-задач, рендер и пр.

<br>

## Для добавления в очередь новой микро-задачи:
Используйте queueMicrotask(f) – асинхронно выполнит функцию в том же состоянии окружения.
Обработчики промисов выполняются в рамках очереди микро-задач.
  
__[Демонстрация работы цикла](http://latentflip.com/loupe)__
