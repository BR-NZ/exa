# Событийный цикл `Event Loop`
Код каждой HTML-страницы в браузере выполняется в Main Thread. Main Thread — это основной поток, где браузер выполняет JS, делает перерисовки, обрабатывает пользовательские действия и многое другое. По сути, это то место, где движок JS интегрирован в браузер.

__Вот упрощенная схема:__  
<img width="650" title="Event Loop" alt="Event Loop" src="https://github.com/BR-NZ/synopsis/assets/24506129/f6ec25ec-25a2-407e-ae7e-99f79761f18f">
<br>
<br>
То есть у нас есть поставщики (или "заказчики исполнения") задач - `Browser API` и `Render`. Каждый из них заполняет очереди из своего типа задач. Единственный их исполнитель - `Callstack`. И координатор между ними, который решает из какой очереди и в каком количестве задачи передать на исполнение - `Event Loop`.

<br>

## Участники
*  `Browser API` отслеживает срабатывание таймаутов, интервалов и DOM-событий на стороне браузера. По мере срабатывания их коллбеки помещаются в очередь `макрозадач` и `микрозадач`:  

* __`Макротаски (tasks queue)`__ – этот тип задача попадает в очередь макро-задач и выполняются из нее по 1й задаче за цикл.

    *	setTimeot / setInterval
    *   console.log
    *   запуск <script>
    *	синхронный код

*  __`Микротаски (microstasks queue)`__ – попадают в очередь микрозадач и выполняются все сразу, то есть другие задачи в промежутках между ними не обрабатываются, это гарантирует неизменность окружения в процессе выполнения микрозадач. Но, если время их выполнения <= времени появления новых - они могут выполняться вечно.

    *   обработчики промисов: .then, .catch, .finally, await (их коллбеки)
    *	mutation observer

*  __`Render API`__ – отрисовывает изменения, этот этап оптимизируется браузером и если изменений нет, он пропускается.

<br>

## Cхема работы

<img width="650" title="Event Loop" alt="Event Loop" src="https://github.com/BR-NZ/synopsis/assets/24506129/450730cd-7ba3-42e2-a1ba-ae205e287373">
<br>
<br>
  
## Алгоритм
Приоритет к выполнению в "цикле событий" всегда имеют макро-задачи. Но такой задачей можеть стать простой запуск скрипта. И тогда первой к выполнению уже внутри скрипта будет очередь микро-задач (все сразу).
0.  Выбрать и исполнить старейшую задачу из очереди макро-задач (например, "run script")
1.  Выполнить все задачи из очереди микро-задач (пока не пуста) 
2.	Выбрать из очереди и исполнить "старейшую" микро-задачу
3.	Отрисовать изменения страницы (если они есть)
4.	Если очередь макро-задач пуста – подождать, пока появится макро-задача
5.	Перейти к шагу 0

<br>

## На словах
__Работают они следующим образом:__ js-движок анализирует код. Когда он встречает вызов какой-то функции, он перемещает эту функцию в `Call Stack`. Если эта функция синхронная (например, `console.log()`), то она сразу же исполняется, покидает стэк и на её место приходит следующая функция. Если же эта функция асинхронная, например, `setTimeout()`, обработчик событий, сетевой запрос и т.д., то на помощь приходит браузер со своим `Web API` (мы же помним, что JavaScript - это однопоточный язык, и сам работать в многопоточном режиме он не может). `Event Loop` перемещает колбэк асинхронной функции в `Web API`, а сама асинхронная функция уходит из стэка вызовов. То есть, пока колбэк асинхронной функции находится под управлением `Web API`, js-движок продолжает выполнять другие операции!

Что же происходит с колбэком? В случае, например, `setTimeout()`, Web API ожидает истечения указанного времени, затем Event Loop перемещает этот колбэк в `Callback Queue` (очередь колбэков). Когда стэк вызовов освобождается, Event Loop перемещает в него наш колбэк из очереди колбэков, после чего колбэк наконец исполняется и покидает стэк вызовов.
    
<br>

## Для разбиения крупной макро-задачи на несколько:
Используйте setTimeout(f) с нулевой задержкой. Это даст пространство для исполнения других участников цикла: микро-задач, рендер и пр.

<br>

## Для добавления в очередь новой микро-задачи:
Используйте queueMicrotask(f) – асинхронно выполнит функцию в том же состоянии окружения.
  
__[Демонстрация работы цикла](http://latentflip.com/loupe)__
