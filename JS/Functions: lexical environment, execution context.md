# Лексическое окружение

## Лексическое окружение (`Lexical Environment`)  
Это скрытый объект, он создается интерпретатором при __каждом новом выполнении функции, блока кода или скрипта__.  

Содержит две части:  

1.	Свойство `Environment Record` (внутреннее окружение) – это объект, в момент выполнения функции в его свойства попадают все локальные переменные внутри блока и переданные при вызове аргументы функции.

2.	Свойство `Scope` (внешнее окружение) – запись со ссылкой на внешнее лексическое окружение, которое соответствует __коду снаружи объявления функции__. Так все функции `«при рождении»` получают значение, которое ссылается на лексическое окружение места, где они были созданы.

* В конце отработки функции ее объект окружения удаляется
* При повтороном запуске создается полностью новый объект (кроме случая возврата функции, в этом случае функция запоминает свое окружение)

## Замкания (`Closures`)
На основе лексического окружения работает эффект `«Замыкания»`: функции и её внешнее окружение.  

Таким образом, любая "переменная" – свойство специального внутреннего объекта: внутреннего окружения `Environment Record`. 
А получить или изменить переменную, означает, получить или изменить свойство этого объекта.

## Глобальное окружение
Помимо всего, есть еще `глобальное окружение`, благодаря ему мы используем функции например `console.log`, `Math.pow` и пр. не задумываюсь откуда они берутся.

## Контекст выполнения
При выполнении любой функции создается специальный объект – контекст выполнения `execution context`. Причём на 1 вызов функции создается ровно 1 объект контекста.

__В нем хранится__ информация о процессе выполнения запущенной функции:
* Конкретное место в коде интерпретатора
* Локальные переменные функции
* Значение this и пр.

__Когда функция производит вложенный вызов:__
1.	Выполнение текущей функции приостанавливается
2.	Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения
3.	Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения
4.	После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена
