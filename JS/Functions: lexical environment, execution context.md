# Лексическое окружение

## Лексическое окружение (`Lexical Environment`)  
Это скрытый объект, он создается интерпретатором при __каждом новом выполнении функции, блока кода или скрипта__.  

Содержит две части:  

1.	Свойство `Environment Record` (внутреннее окружение) – это объект, в момент выполнения функции в его свойства попадают все локальные переменные внутри блока и переданные при вызове аргументы функции.

2.	Свойство `Scope` (внешнее окружение) – запись со ссылкой на внешнее лексическое окружение, которое соответствует __коду снаружи объявления функции__. Так все функции `«при рождении»` получают значение, которое ссылается на лексическое окружение места, где они были созданы.

* В конце работы функции ее объект окружения удаляется
* А при повтороном запуске создается полностью новый объект 
* (кроме случая если функция `return` из другой функции – в этом случае функция запоминает свое окружение)

<br>

## Замкания (`Closures`)
На основе лексического окружения работает эффект `«Замыкания»`: совокупность функции + её внешнее окружение.  

Таким образом, любая `переменная` – это свойство специального объекта её внутреннего окружения `Environment Record`. 

А получить или изменить переменную – означает, получить или изменить свойство этого объекта.

<br>

## Глобальное окружение
Помимо всего, есть еще `глобальное окружение`, благодаря ему мы используем функции например `console.log`, `Math.pow` и пр. не задумываюсь откуда они берутся.

<br>

## Контекст выполнения
При выполнении любой функции создается специальный объект – контекст выполнения `execution context`. Причём на 1 вызов функции создается ровно 1 объект контекста.

__В нем хранится__ информация о процессе выполнения запущенной функции:
* Конкретное место в её коде в процессе работы интерпретатора
* Локальные переменные функции
* Значение `this` и пр.

__Когда функция производит вложенный вызов:__
1.	Выполнение текущей функции приостанавливается
2.	Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – `стеке контекстов выполнения`
3.	Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения
4.	После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена
