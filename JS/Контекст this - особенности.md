# Контекст this
В `javascript` в отличии от других языков программирования контекст функции `this` не привязан к конкретной функции. В зависимости от окружения и типа функции контекст __может иметь разное значение__:
1.	Внутри глобальных функций:  
      `обычная f()` ==> `this === window` как внешний к ней объект  
      `strict mode` ==> `this === undefined`  
2.	Внутри метода объекта или класса:  
      `обычная f()` ==> `this === объекту перед точкой`  
3.	Внутри внешней функции:  
      `обычная f()` ==> `this === undefined`  
      `стрелка ()` ==> `this === берут this у внешней функции, где создавались`  
4.	Внутри колбек-функции события:  
  	  `обычная f()` ==> `this === объекту с навешанным событием`  
      `стрелка ()` ==> `this === undefined`  

<br>

## Привязка контекста
* __`func.call(context, arg1, arg2, ...)`__ – вызывает с заданным `this` и списком аргументов;
* __`func.apply(context, [arg1, arg2, ...])`__ – вызывает с заданным `this` и псевдо-массивом аргументов;
* __`const boundFunc = func.bind(context)`__ – будет создана новая функция с привязанным `this` (такие функции можно без опаски передавать как коллбеки, конекст не потеряется);
* __`this.boundFunc = this.func.bind(context)`__ - то же самое, но внутри классов.

<br>

## Потеря контекста `this`
Объяснение на пальцах:  
1.	`Обычная f()` – `this` === `window` (в `strict mode`):
```javascript
function test() {
  console.log( this )
}

test() // вернет window (как внешний объект)
```

2.	`Обычная f()` в объекте/классе (метод) – `this` всегда ссылается `на объект вызова` перед `.`( мы вызываем ее из объекта):
```javascript
const testObj = {
  test() { console.log( this ) }
}

testObj.test() // вернет сам объект вызова testObj (как объект до точки)
```

3.	Но! Как только `Обычная f()`, например метод из объекта, копируется снаружи как простое тело функции – __контекст "теряется"__, потому что в новой функции `this` будет ссылаться на нового родителя (напр. window). 
Как раз это и происходит, когда вы передаете ссылку на функцию в обработчик события. Функция теперь находится вне объекта:
```javascript
const testObj = {
      test() { console.log( this ) }
}

// при копировании в переменную попадает тело функции (уже без контекста)
const otherFunc = testObj.test

otherFunc() // получаем window (как внешний объект к новой функции), а не testObj
```
4.	Но `стрелки f()` лишены этой проблемы, их контекст __железно привязан к месту, где они были созданы__. Они всегда будут брать `this` у своего `первоначального родителя` вне зависимости от расположения:
```javascript
class Test {
      test = () => {
            console.log( this )
      }
}
const obj = new Test()

// также копируем функцию в переменную
const otherFunc = obj.test

otherFunc() // но получаем все равно объект obj (а не window)
```

<br>

## Вывод:
Используем __функции-стрелки__ – если хотим передать в качестве колбека функцию, использующую в своем теле `this`.
Либо привязываем контекст напрямую, например, специальным методом `bind()`.
