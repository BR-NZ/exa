# Контекст this

В зависимости от окружения и ситуации __может иметь разное значение__:
1.	Внутри глобальных функций `this === window` (в `strict mode` === `undefined`)
2.	Внутри метода объекта или класса `this === объекту или экземпляру класса`
3.	Внутри вложенной функции `this === undefined` (функции-стрелки берут `this` у внешней функции, где создавались);
4.	Внутри колбек-функции события `this === объекту с навешанным событием` (у функций стрелок undefined)

<br>

## Привязка контекста
`func.call(context, arg1, arg2, ...)` – вызывает с заданным this и списком аргументов.
`func.apply(context, [args])` – вызывает с заданным this и псе-массивом аргументов.
`const [this.]boundFunc = [this.]func.bind(context)` – будет создана новая функция с привязанным this (такие функции можно передавать как коллбеки).

## Потеря контекста `this`
Объяснение на примерах:  
1.	`Обычная f()` – `this` === `window` (в `strict mode`):
```javascript
function test() {
  console.log(this)
}
test() // вернет window
```
2.	`Обычная f()` в объекте/классе (метод) – `this` всегда ссылается `на объект вызова` перед `.th. Потому что здесь мы вызываем ее из объекта:
```javascript
const testObj = {
  test() { console.log(this) }
}
testObj.test() // вернет сам объект вызова testObj
```

Но! Как только обычная функция (метод) куда-то передается как простое тело функции, то контекст "теряется", потому что в новой функции this будет ссылаться на нового родителя (напр. window). 
Как раз это и происходит, когда вы передаете ссылку на функцию в обработчик события. Функция теперь находится вне объекта:
 
Но функции (метод) стрелки лишины этой проблемы, их контекст железно привязан к месту, где они были созданы. Они всегда будут брать this у своего первоначального родителя вне зависимости от расположения:
 
