# Контекст this
В `javascript` в отличии от других языков программирования контекст функции `this` не привязан к конкретной функции. В зависимости от окружения и типа функции контекст __может иметь разное значение__:
1.	Внутри глобальных функций:  
      `обычная f()` ==> `this === window` как внешний к ней объект  
      `strict mode` ==> `this === undefined`  
2.	Внутри метода объекта или класса:  
      `обычная f()` ==> `this === объекту перед точкой`  
3.	Внутри внешней функции:  
      `обычная f()` ==> `this === undefined`  
      `стрелка ()` ==> `this === берут this у внешней функции, где создавались`  
4.	Внутри колбек-функции события:  
  	  `обычная f()` ==> `this === объекту с навешанным событием`  
      `стрелка ()` ==> `this === undefined`  

<br>

## Привязка контекста
`func.call(context, arg1, arg2, ...)` – вызывает с заданным `this` и списком аргументов.
`func.apply(context, [args])` – вызывает с заданным `this` и псе-массивом аргументов.
`const [this.]boundFunc = [this.]func.bind(context)` – будет создана новая функция с привязанным `this` (такие функции можно передавать как коллбеки).

## Потеря контекста `this`
Объяснение на пальцах:  
1.	`Обычная f()` – `this` === `window` (в `strict mode`):
```javascript
function test() {
  console.log( this )
}

test() // вернет window (как внешний объект)
```

2.	`Обычная f()` в объекте/классе (метод) – `this` всегда ссылается `на объект вызова` перед `.`( мы вызываем ее из объекта):
```javascript
const testObj = {
  test() { console.log( this ) }
}

testObj.test() // вернет сам объект вызова testObj (как объект до точки)
```

Но! Как только обычная функция (метод) куда-то передается как простое тело функции, то контекст "теряется", потому что в новой функции `this` будет ссылаться на нового родителя (напр. window). 
Как раз это и происходит, когда вы передаете ссылку на функцию в обработчик события. Функция теперь находится вне объекта:
```javascript
const testObj = {
      test() { console.log( this ) }
}

// при копировании в переменную попадает тело функции (уже без контекста)
const otherFunc = testObj.test

otherFunc() // получаем window (как внешний объект к новой функции), а не testObj
```
Но функции (метод) стрелки лишины этой проблемы, их контекст __железно привязан к месту, где они были созданы__. Они всегда будут брать `this` у своего `первоначального родителя` вне зависимости от расположения:
```javascript
class Test {
      test = () => {
            console.log( this )
      }
}
const obj = new Test()

// также копируем функцию в переменную
const otherFunc = obj.test

otherFunc() // но получаем все равно объект obj (а не window)
```

__Поэтому: используем функции-стрелки – если хотим передать в качестве колбека функцию, использующую в своем теле `this`.
