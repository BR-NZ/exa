# JS: Типы, сравнение, особенности

<br>

## Типы
Обобщенно в JS всего 2 вида значения: `примитивы` и `объекты`.  

__Примитивы:__ `string`, `boolean`, `number` (NaN, +/-Infinity), `bigInt`, `symbol`, `undefined`, `null`.
* всегда равны друг другу (кроме NaN != NaN)
* примитивы иммутабельны, само значение не изменить, только переменную
* передаются в функцию по значению, сама переменна остается неизменной

__Объектные (ссылочные)__: `object`, `class`, `func`, `array` и пр.
* ключи у объектов могут быть только строки и символы (или будет приведен к строке)
* объектные типы мутабельны, можно изменить содержимое объекта
* передаются по ссылке, а значит могут быть изменены внутри функции

<br>

## Хранение
`Стэк (stack)` – структура данных, использующейся под хранения статических данных, чей размер известен до выполнения (статическое выделение памяти).
* В стэке хранятся примитивные значения
* У непримитивов: в стэке хранятся ссылки на область в памяти кучи

`Куча (heap)` – динамическая структура данны, в ней хранятся функции и объекты (массивы и пр.), то есть сущности, чей размер не может быть известен заранее.  
* В куче нет какого-либо порядка в расположении данных (динамическое выделение памяти)
* У непримитивов: в стэке хранятся ссылки на область в памяти кучи

<br>

## Symbol
Отдельный тип данных, выглядит как `ID-индетификтор` и служат для создания свойств и методов объектов c уникальными именами. Поэтому за них не нужно переживать по поводу перезаписи или случайного доступа (нельзя вывести конкретное значение переменной этого типа - оно скрыт).   

Существует два типа символов:  

1.  __Симвов без привязки к описанию:__ каждый вновь созданный символ с тем же описанием не будет равен предыдущему – это фактически новый символ.
```javascript
let sym1 = Symbol(‘desc..’) 
// создаем простой всегда уникальный символ
// описание нужно только для отладки
```
2.  __Симвов реестровый:__ значение такого символа создается на основе заданного описания, каждый вновь созданный символ с тем же описанием будет ссылаться на тот же символ.
```javascript
let sym2 = Symbol.for(‘desc..’)
// создаем символ с привязкой к описанию
// создать еще один символ с тем же описание - не выйдет (это будет тот же символ)

let desc = Symbol.key( sym2 )
// вывод описания символа
```

<br>

## `?.` Опциональная цепочка
Работает на __проверку левой части выражения на null/undefined__: предотвращает ошибку обращения к ним
`user.property` – выдаст ошибку если вдруг user не существует.
`user?.property` – сначала проверит левую часть не опеределенность. В ином случае вернет не ошибку, а undefined.

<br>

## Сравнение
1. __`||` — «ИЛИ спотыкается на правде»__
```javascript
(false || 0 || null || 1 || undefined) === 1
// вернет в цепочке первое истинное выражение

(false || 0 || null || ‘’ || undefined) === undefined
// когда истинных выражений в цепочке нет – вернет последнее 
```
Оператор `ИЛИ` проходит цепочку сравнений только __до первого истинного выражения__ и просто возвращает именного его.

2. __`??` — «НУЛЕВОЕ СЛИЯНЕ спотыкается на ОПРЕДЕЛЕННОМ выражении»__
```javascript
(undefined ?? null ?? 0) === 0
// вернет 0 как первое опеределенное выражение в цепочке

(undefined ?? '' ?? 0) === ''
// вернет '' как первое опеределенное выражение в цепочке

(undefined ?? null ?? undefined) === undefined
// когда определенных выражений в цепочке нет - вернет последнее 
```
Оператор `NULLISH` проходит цепочку сравнений только `до первого определенного выражения` и возвращает его. В отличии от `ИЛИ` он __учитывает 0 и пустую строку__ и может их вернуть).

3.  __`&&` — «И спотыкается на лжи»__
```javascript
(1 && 2 && null && 1 && undefined) === null
// вернет первое ложное выражение в цепочке

(1 && 'test' && [] && true && 4) === 4
// когда ложных выражений в цепочки нет - вернет последнее
```
Оператор `И` проходит цепочку сравнений только `до первого ложного выражения` и возвращает его.

<br>
