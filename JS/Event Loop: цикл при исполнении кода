# Событийный цикл `Event Loop`

Это бесконечная «карусель», которая собирает задачи __из 2 очередей__: `макро` и `микро задач`.

## Последовательность задач
Задачи выполняются в следующей последовательности:

1.	`Макротаски (message queue)` хранятся в очереди (FIFO), выполняются по 1й за цикл и не выполняются, пока стек вызовов не опустеет от текущего синхронного кода, после чего `из очереди` функции-коллбеки попадают `в стек вызовов`.
Среди них: 
*	setTimeot / setInterval
* console.log
* <script>
*	синхронный код

2.	`Web API (Node)` отслеживает срабатывание таймаут, интервал или события. По мере срабатывания их коллбеки помещаются в очередь макрозадач.

3.	`Микрозадачи (promise jobs)` выполняются все сразу, хранятся в «очереди» (LIFO). Другие задачи в промежутках между микро-задачами не отрабатываются, это гарантирует неизменность окружения в процессе выполнения микрозадач.
* .then.catch.finally (их коллбеки)
*	await (код после)

2. Микро-таск – выполняются все сразу, хранятся в «очереди» (LIFO). Другие задачи в промежутках между микро-задачами не отрабатываются, это гарантирует неизменность окружения в процессе выполнения микрозадач.
-	
3. Рендер – отрисовка изменений в браузере.
4. Web APIs – периодически задачи в очередь подкидывает браузер, который ответственен за работу setTimeout, setInterval, Events и отслеживание необходимости выполнения переданных им каллбеков.
Алгоритм
Выбрать и исполнить старейшую задачу из очереди макро-задач (например, «script»).
Исполнить все микро-задачи:
1.	Пока очередь микро-задач не пуста: 
2.	Выбрать из очереди и исполнить старейшую микро-задачу
3.	Отрисовать изменения страницы, если они есть.
4.	Если очередь макро-задач пуста – подождать, пока появится макро-задача.
5.	Перейти к шагу 1.

<br>

## Для разбиения крупной макро-задачи на несколько:
Используйте setTimeout(f) с нулевой задержкой. Это даст пространство для исполнения других участников цикла: микро-задач, рендер и пр.

<br>

## Для добавления в очередь новой микро-задачи:
Используйте queueMicrotask(f) – асинхронно выполнит функцию в том же состоянии окружения.
Обработчики промисов выполняются в рамках очереди микро-задач.
