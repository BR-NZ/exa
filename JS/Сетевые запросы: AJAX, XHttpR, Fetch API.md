# AJAX, XHttpR, Fetch API

__`AJAX (Async Javascript And Xml)`__ – подход и методика по асинхронной динамической подгрузке данных, не приводящей к перезагрузке страницы.

Такие запросы производятся через стандартные методы (включенные в язык): XMLHttpRequest, Fetch API. А также дополнительные методы (из библиотек): Axios и пр.

## Заголовки `headers` для HTTP-post запросов (по типам данных)
Данные заголовки необходимо указывать при любом используемом API: `Fetch`, `XHttpRequest`, `Axios`.
```javascript
// JSON:
‘Content-type’ : ‘application/json’
// FormData:
‘Content-type’ : ‘multipart/form-data’ (его не указывать, он ставится сам)
// Text:
‘Content-type’ : ‘text/plain’
// IMG:
‘Content-type’ : ‘’
// Опционально: добавить ко всем ‘charset=UTF-8’
```

<br>

## XMLHttpRequest API
__`XMLHttpRequest`__ – изначально был разработан Microsoft, но позже заимствован Mozilla, Apple, и Google. Сейчас он входит в станарт и несмотря на своё название, может быть использован для получения любых типов данных, не только `XML`, и поддерживает не только `HTTP-протокол,` но и `FILE` и `FTP`. 

```javascript
// 0. С помощью спец-класса создаем объект запроса
const myRequest = new XMLHttpRequest();

// 1. Метод для настройки будущего запроса
myRequest.open(
  ‘GET/POST/PUT..’ – метод запроса (для GET необязательно), 
  ‘URL’ – адрес к файлу относительно html-страницы,
  *TRUE/FALSE* – флаг вкл/выкл асинхронность запроса (опционально),
  LOGIN*, PASS* – при запросах по доступу (опционально)
);

// 2. Запись заголовка Http-запроса (какого типа данные ожидаем)
myRequest.setRequestHeader( ‘Content-type’, ‘тип-данных’ );

// 3. Отправляем тело запроса – для POST методов (для GET – ничего)
myRequest.send( BODY (если POST) / ничего (если GET) );

// 4. Запрос асинхронен, нужно повешать обработчика его состояния загрузки
myRequest.addEventListener('load', (res) => {
  // 5. В обработчике можем работать с готовым объектом-запроса
  console.log( res )
})
```

<br>

### Среди интересных событий:
* `readystatechange` – отслеживает факт изменения стадии готовности запроса, а именно свойства readyState;
* `load` – срабатывает при значении свойства readyState = 4;

### Объект запроса XMLHttpRequest сожержит полезные свойства, получаемые при его исполнении:
* `.status` – числовое представление ответа сервера, до выполнения = 0;
* `2хх` - все ок, `3хх` - редирект, `4хх` - ошибка клиента, `5хх` - ошибка сервера;
* `.statusText` – словесное представление ответа сервера с описанием;
* `.readyState` – числовое представление этапа готовности запроса от 0 до 4;
* `.response` – сам ответ сервера, то что в body теле ответа;

| Значение  | Состояние (readyState) | Состояние |
|-----------|------------------------|-----------|
| 0 | UNSENT | Объект был создан. Метод `open()` ещё не вызывался. |
| 1 | OPENED | Метод `open()` был вызван |
| 2 | HEADERS_RECEIVED | Метод `send()` был вызван, доступны заголовки (headers) и статус. |
| 3 | LOADING | Загрузка; responseText содержит частичные данные. |
| 4 | DONE | Операция полностью завершена. |

<br>
<br>

## Fetch API

__`Fetch()`__ – новый и мощный метод для подгрузки данных с помощью сетевых запросов. Он не поддерживается старыми браузерами, но работает во всех соверменных.

__Базовый синтаксис:__  
```javascript
let promise = fetch(url, [options])
```

<br>

### GET-запросы
Обычный GET-запрос, скачивающий данные по URL, не требует объекта `options`. Браузер сразу начнет запрос данных и вернет промис, который внешний код использует для получения результата.

__Процесс получения ответа состоит из 2-х этапов:__  
1.	Первом этап: промис выполнится с результатом в виде объекта встроенного класса `Response` – как только сервер пришлет заголовок ответа.
На этом этапе мы можем проверить `HTTP-статус` ответа сервера и определить выполнился ли он успешно, просмотреть заголовки, но пока без самого тела.
Промис на этом этапе завершиться ошибкой только в случае проблем с сетью или если нет такого сайта. Коды 404 или 500 не являются ошибками для него.

__Мы можем увидеть статус в свойствах ответа:__  
* `response.status` – числовой код ответа сервера (2хх, 3хх, 4хх, 5хх);
* `response.ok` – булевое значение (true при кодах 200-299, flase - при остальных);

2.	На втором этапе: мы уже можем получить тело `body` ответа с результатом запроса.

__Полученный объект класса `Response` представляет несколько методов для этого:__  
* `response.text()` – читает ответ и возвращает как обычный текст;
* `response.json()` – декодирует ответ в формате `json` в объект;
* `respone.formData()` – возвращает ответ как объект `FormData`;

__Установка заголовков:__  
За это отвечает свойство `headers` в объекте `options`, который получает `fetch()`.

```javascript
{
  // например, установим способ доступа
  headers: { Authentication: 'secret' },
}
```

<br>

### POST-запросы
Для отправки `POST-запросов` нужно настроить объект `options` и передать его `fetch()`:

```javascript
{
  method: ‘POST/GET/PUT/PACTH/DELETE’,
  headers: {‘Content-type: application/json’, …},
  body: JSON.stringify(user)
}
```
В `body` - то есть теле запроса могут содержаться разные данные, которые мы хотим отправить на сервер: строка (например JSON), объект FormData и пр. 

Если сервер не в состоянии принять объект `FormData`, его необходимо превратить в обычный объект простым копированием и только потом отправлять в виде `JSON-объекта`.

В ответ мы получим какой-то подготовленный под этот запрос ответ сервера.
