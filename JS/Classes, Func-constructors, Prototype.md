# Функции-конструкторы, классы и прототипы

В `javascript` все типы данных основаны на объектах.  

## Прототипы
Объекты имеют специальное скрытое свойство `[[Prototype]]`, оно либо равно `null`, либо ссылается на другой объект – `прототип`:
<br>
<img width="200" alt="Прототип" title="Прототип" src="https://github.com/BR-NZ/synopsis/assets/24506129/a9eee6fe-945b-4be1-8ed9-2d3d0687b06b">
<br>
### Магия прототипа
Прототип это особенный объект, он привязывается к новым сущностям, и когда какой-либо метод или свойство на сущности не найдет, `javascript` автоматически будет искать его в прототипе. Таким образом в прототипе можно размещать `общий код`, который будет расширять все вновь созданные на его основе сущности.
<br>
<img width="650" alt="Диаграмма наследования" title="Диаграмма наследования" src="https://github.com/BR-NZ/synopsis/assets/24506129/390c56c8-a432-45cb-ba50-3e88ecc541a6">
<br>

### Прототип у прототипа
Ничего не мешает выстроить объекты прототипа в цепь, один объект прототипа будет в `[[Prototype]]` иметь ссылку на другой объект-прототип. В этом случае `javascript` при поиске свойства или метода на объекте будет автоматически проходить по всей цепочке объектов-прототипов. Так реализуется принцип `прототипного наследования`.

### Как получить прототип
Свойство `[[Prototype]]` является внутренним и скрытым, но есть несколько вариантов:  

* `__proto__ (устарело)` – гетер закрытого свойства [[Prototype]] ссылается на объект-прототип, содержащий общие свойства и методы для всех экземпляров, оно есть у всех созданных экземпляров.

* `Object.getPrototypeOf(someObj) (новый)` – статический метод, также как и `__proto__` применяется на объекте, вернет объект-прототипа.

* `prototype` – это свойство есть только у классов и функций, также ссылается на объект прототипа, который будет присвоен экземплярам, созданным на основе этих функций и классов.

* `contructor` – это свойство есть у объектов-прототипов, и оно наоборот ссылается на класс или функцию к которому этот прототип привязан для создания сущностей.

<img width="650" alt="Диаграмма функции-конструктора и экземпляров" title="Диаграмма функции-конструктора и экземпляров" src="https://github.com/BR-NZ/synopsis/assets/24506129/c338645d-e15e-4cdd-b880-2e9a37c10fb4">

<br>
<br>

## Функции-конструкторы
Это просто функции, их принято именовать с заглавной, они конфигурируют объект под временным именем `this`, а затем неявно его возвращают:  
```javascript
function User(name) {
  // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно)
}

const user = new User('Alex')
```
`Вызов с оператором new..` - запускает такое спецефичное поведение функции-конструктора.

Все записи в во временный объект `this` попадут непосредственно в новый объект. Поэтому чтобы избежать дублирования одинаковых для все сущностей `методов - их лучше размещать в общем объекте-прототипе`. А в функции-конструкторе записывать в `this` только свойства, чьи значения могут отличаться и меняться для каждой сущности.

<br>

## Классы
Классы основаны на функциях – отчасти, это синтаксический сахар языка. К примеру, у них один тип данных:   
```javascript
typeof Class1 === typeof func1
// true - ведь классы и функции имеют один тип 'function'
```

### Класс = функция(конструктор) + прототип
Класс - более удобная конструкция функции-конструктора с прототипом
```javascript
class User {
	// можно задавать свойства вне конструктора, они также попадут в this (но не в prototype)
	name = 'Alex';

	// можно задавать геттер-свойства 
	get name() {
	    return this._name;
	}
	// а также сеттер-свойства
	set name(value) {
	    if (value.length < 4) {
		alert("Имя слишком короткое.");
		return;
	    }
	    this._name = value;
	}

	constructor(name) {
		// this.данные в конструкторе попадут в каждый экземпляр класса new User()
		this.name = name
	}

	// методы снаружи констуктора попадут в общий прототип класса User.Prototype
	sayHi() { alert(this.name) }
}
```

### То же самое в функции-конструкторе:
```javascript
function User(name) {
	// код здесь как в методе constructor() у класса
	this.name = name
}

// прямая запись в прототип, чтобы не дублировать общие методы для каждого созданного объекта
User.prototype = {
	sayHi: function() { alert(this.name) }
}
```

### Из отличий:
* Весь код внутри класса работает в режиме `use strict`
* Методы объекта, созданного классом - неперечисляемые (класс ставит им `enumerable: false`)

<br>

## Оператор `instanceof`
Оператор `instanceof` проверяет, принадлежит ли сущность к определённому классу или функции-конструктору (создан ли он или его предок на их основе). 

### Синтаксис:
```javascript
[object] instanceof [constructor]
```

### Алгоритм:
Проверяет наличие объекта прототипа данного конструктора `constructor.prototype` в цепочке наследований прототипов объекта `object.__proto__.__proto__`...

<br>

## Примеры:
1.	Свойство `__proto__` созданного объекта и свойство `prototype` его конструктора (функции или класса) ссылаются на один и тот же объект-прототип.
```javascript
const obj1 = {}
obj1.__proto__ === Object.prototype
```
2.	Классы и функции произошли от функции-конструктора – поэтому у них один общий объект-прототип.
```javascript
SomeClass.__proto__ === Function.prototype
SomeFunc.__proto__ === Function.prototype
```
3.	Даже примитив имеет `proto` свойство, т.к. создает временную объект-оболочку с помощью своего конструктора (здесь «Number»). 
```javascript
const count = 1
count.__proto__ === Number.prototype
```
