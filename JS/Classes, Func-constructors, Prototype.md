# Прототипы

![Диаграмма наследования](https://github.com/BR-NZ/synopsis/assets/24506129/c4f82905-634c-404d-8b9a-fd409fdbb8db "Диаграмма наследования")

Классы основаны на функциях – это синтаксический сахар, поэтому:  
```javascript
typeof Class1 === typeof func1 
// вернет “Function” - класс имеет тип данных функции
``` 

![Диаграмма класса и экземпляров](https://github.com/BR-NZ/synopsis/assets/24506129/f6af041a-af26-4c9a-a11e-7cadcaae35d5 "Диаграмма класса и экземпляров")


1.	`__proto__` – гетер закрытого свойства [[Prototype]] ссылается на объект прототип, содержащий общие свойства и методы для всех экземпляров, он есть у всех типов данных. (есть более новый статический метод Object.getPrototypeOf(obj1))

2.	`prototype` – это свойство есть только у классов и функций, также ссылается на объект прототипа, который будет присвоен экземплярам, созданным на основе этих функций и классов.

<br>

## Примеры:
1.	Свойство __proto__ созданного объекта === свойству prototype его конструктора (функции или класса), так как они ссылаются на один и тот же объект-прототип.
```javascript
object1.__proto__ === Object.prototype === object2.__proto__
```
2.	Примитив тоже создает временную объект-оболочку с помощью конструктора (класса или функции), например «Number». Поэтому 
`__proto__ потомка === prototype` конструктора (функции или класса).
```javascript
age.__proto__ === Number.prototype
```
3.	Классы и функции произошли от функции-конструктора – поэтому они все своими свойствами ссылаются на один и тот же объект-прототип.
```javascript
someClass.__proto__ === Function.prototype === someFunc.__proto__
```

<br>

## `instanceof`
Оператор `instanceof` проверяет, принадлежит ли объект к определённому классу (функции-конструктору). 

Другими словами:  
```javascript
[object] instanceof [constructor]
```

Проверяет наличие объекта прототипа данного конструктора `constructor.prototype` в цепочке наследований прототипов объекта `object.__proto__.__proto__`...
