# Модули

__Модуль__ – упрощенно, это один файл (скрипт) со своей областью видимостью.  

* В модуле __всегда строгий режим__: код внутри модуля всегда работает в режиме `strict mode`.  
* А сами скрипты с type=”module” работают в defer (отложенном) режиме.  

Любые модули должны собраться в один результирующий файл. Браузер не умеет объединять модули (стандарта ES6 или CommonJS), поэтому для сборки применяют дополнительные инструменты.  

<br>

## Анонимная самовызывающаяся функция
Конструкция для изолирования кода от внешнего окружения, создает отдельный модуль со своей областью видимости.  
```javascript
( function() { … содержимое }() )
```

<br>

## Объектный интерфейс
Усовершенствованная конструкция, как анонимная самовызывающаяся функция, но возвращает объект с полями, которые мы хотим применять снаружи функции.  
```javascript
const user = (function() {
    privateProp…
    return { prop: privatProp }
}())

user.prop… //получаем свойства снаружи функции
```

<br>

## Модули в CommonJS
Редкий и старый синтаксис для создания модулей, экспорта и импорта. Изначально создан для Node.js.  

_**Чтобы экспортировать** какую-любо сущность из одного файла:_
```javascript
function someModule() { … содержимое } //создаем сущность
module.exports = someModule; //помещаем в объект для экспорта
```

_**Чтобы импортировать** сущность в файл:_
```javascript
const someModule = require(“./путь ”); //импортируем сущность
````
Путь может быть относительно файла или абсолютный.

<br>

## Модули в ES6
Новый стандарт создания модулей для сборщиков появился в ES6 2015. Существует два вида экспорта/импорта: именованный и дефолтный.  

_**Чтобы экспортировать** какую-любо сущность из одного файла:_
```javascript
export function someFunc() { … } //именованный экспорт при объявлении

export { someFunc, someVar2 as var2 }; //именованный экспорт (в объект)

export default function someFunc() {…} //дефолтный экспорт
```
__Дефолтный экспорт__ может быть __только один__ в модуле. При импорте ему сразу можно дать другое им - но лучше этого не делать.  

_**Чтобы импортировать** сущность в файл:_
```javascript
//импорт именованных сущностей (деструктурируем)
import { someFunc, someVar2 as var2 } from “./путь”;

//импорт всего (весь объект)
import * as data from “./путь”;

//импортируем дефолтные сущности (без скобок, имя можно выбрать любое)
import someFunc from “./путь”;
```

__Код модуля выполняется только один раз__ при первом импорте, в дальнейших импортах будет отдаваться готовый результат. 

<br>

## Динамический импорт
Иногда нам нужно подгрузить функциональность или данные из сторонних модулей не сразу при загрузки приложения, а при выполнении определенного условия.  
`import( module )` – выражение загружает модуль и возвращает промис, результатом которого становится объект модуля, содержащий все его экспорты. Это асинхронная операция, мы не знаем как долго будет подгружаться модуль.

```javascript
// Динамический импорт возможен внутри условий
if ( logged ) {  import( ../путь )  }

// И дальше можем с ним работать в асинхронном стиле
import( ../путь ) // получаем промисс, который вернет объект с содержимым
    .then(obj => /* объект модуля - работаем с ним */)
    .catch(err => /* ошибка загрузки */)

// Внутри async функции:
const moduleObj = await import( ../путь ) // получим объект с сущностями
const { func1, func2 } = await import( ../путь ) // или сразу деструктурируем сущности
moduleObj.default // Если сущность экспортировалась по умолчанию, то она доступна в объекте по ключу дефолт
```

Таким образом, тяжелые сущности (функции, объекты и пр.) можно загружать не сразу, а по надобности в ходе работы приложения.
